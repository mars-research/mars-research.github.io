<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Kernel Development with Qemu (Printing &#34;Hello World&#34; On Bare Metal) | Mars Research Group</title>
<meta name="keywords" content="" />
<meta name="description" content="How to get started with kernel development on Qemu platform">
<meta name="author" content="Anton Burtsev">
<link rel="canonical" href="https://mars-research.github.io/posts/2020/10/hello-world-on-bare-metal/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.6f60056d44d3f7eb69a4bc6c332b59960f3a995802bded244750232f33713c49.css" integrity="sha256-b2AFbUTT9&#43;tppLxsMytZlg86mVgCve0kR1AjLzNxPEk=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mars-research.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mars-research.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mars-research.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mars-research.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://mars-research.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.88.1" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Kernel Development with Qemu (Printing &#34;Hello World&#34; On Bare Metal)" />
<meta property="og:description" content="How to get started with kernel development on Qemu platform" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mars-research.github.io/posts/2020/10/hello-world-on-bare-metal/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-28T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-10-28T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kernel Development with Qemu (Printing &#34;Hello World&#34; On Bare Metal)"/>
<meta name="twitter:description" content="How to get started with kernel development on Qemu platform"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blog",
      "item": "https://mars-research.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Kernel Development with Qemu (Printing \"Hello World\" On Bare Metal)",
      "item": "https://mars-research.github.io/posts/2020/10/hello-world-on-bare-metal/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kernel Development with Qemu (Printing \"Hello World\" On Bare Metal)",
  "name": "Kernel Development with Qemu (Printing \u0022Hello World\u0022 On Bare Metal)",
  "description": "How to get started with kernel development on Qemu platform",
  "keywords": [
    
  ],
  "articleBody": "If you plan to start working on a new operating system kernel things get hard fast—there is a ton of low-level hardware details you have to understand and a number of design decisions you have to make (after all, why would you build yet another kernel—you have to invent something new, right?). Complexity is intimidating. Nevertheless, if you take it step by step, the basics are simple. And it’s worth trying. We’re sure you’ll venture into your own kernel story—multicore-scalability, security, safety, fast device access,\nThis post provides a minimal set of steps needed to print “Hello world!” on the screen.\nQemu: the Fastest Way to Start The fastest way to get started on a new kernel is to use a virtual machine like Qemu. Note, we like Qemu the most because it is open source (if things go wrong, you can actually debug what is going on), and good support on Linux servers (we carry most of our development remotely in a baremetal datacenter, and Qemu just works out of the box). Compared to running on real hardware (which has a long reboot cycle, and limited debugging mechanisms), development under a virtual machine, e.g., Qemu has a much quicker cycle and gives a ton of debugging opportunities (e.g., attaching GDB, dumping page tables, understanding triple faults, etc.). Moreover, for serious kernel development, the Qemu+KVM bundle provides performance that is nearly identical to bare metal for most workloads, i.e., a nested page table slows you down by a couple of percents on workloads that touch a lot of memory, e.g., a hash table, but overall by running on Qemu+KVM you get a fair estimate of your system’s performance.\nQemu can boot a multiboot-compatible kernel with the (-kernel) option. Multiboot is a general specification. This is convenient, it can be booted by any multiboot-compatible boot loader, e.g., GRUB—this makes it convenient the moment you are ready to test your kernel on real hardware you can boot it with GRUB (see below).\nThe Multiboot specification requires that the kernel binary starts with a special header. We will make this header in two steps: 1) we will use assembly to create specific header constants (it’s possible to make the header in C, but what if you program your kernel in Rust?) and 2) we will use a linker script to make sure that the header is placed exactly at the beginning of the kernel binary.\nMultiboot Header A multiboot header is easy (the code is adapted from “Writing kernels that boot with Qemu and Grub” tutorial by Herbert Boss and it uses the Intel assembly):\n; Multiboot v1 - Compliant Header for QEMU ; We use multiboot v1 since Qemu \"-kernel\" doesn't support ; multiboot v2  ; This part MUST be 4-byte aligned, so we solve that issue using 'ALIGN 4' ALIGN 4 section .multiboot_header ; Multiboot macros to make a few lines later more readable  MULTIBOOT_PAGE_ALIGN\tequ 10 MULTIBOOT_MEMORY_INFO\tequ 11 MULTIBOOT_HEADER_MAGIC\tequ 0x1BADB002 ; magic number  MULTIBOOT_HEADER_FLAGS\tequ MULTIBOOT_PAGE_ALIGN | MULTIBOOT_MEMORY_INFO ; flags  MULTIBOOT_CHECKSUM\tequ - (MULTIBOOT_HEADER_MAGIC + MULTIBOOT_HEADER_FLAGS) ; checksum  ; (magic number + checksum + flags should equal 0)  ; This is the GRUB Multiboot header. A boot signature  dd MULTIBOOT_HEADER_MAGIC dd MULTIBOOT_HEADER_FLAGS dd MULTIBOOT_CHECKSUM Here we first define several constants, e.g., MULTIBOOT_PAGE_ALIGN, MULTIBOOT_MEMORY_INFO, MULTIBOOT_HEADER_MAGIC, combine them into MULTIBOOT_HEADER_FLAGS and MULTIBOOT_CHECKSUM, and then define the header as three 4 byte values in the last three lines.\nWhile this looks criptic in practice it’s rather simple. Go ahead and read the Multiboot Specification, Section 3.1.1 to see which fields are put inside the header.\nWe can compile this with nasm like\nnasm -felf32 multiboot_header.asm -o multiboot_header.o Linker Script Now we need to compile a kernel binary in such a way that the multiboot header appears as the first section in the ELF file. For this we will use a linker scripts that instructs the linker to copy sections from multiple files in a specific order:\nENTRY(start) SECTIONS { . = 0x100000; /* Tells GRUB to load the kernel starting at the 1MB */ .boot : { /* Ensure that the multiboot header is at the beginning */ *(.multiboot_header) } .text : { *(.text) } } Here we specify that the kernel entry point will be the start label. The bootloader that understand ELF format will load the kernel in memory (by the way, we ask to load the kernel at address 0x100000) and will jump to the entry point specified in the ELF header. The linker will arrange that the ELF entry point points to the start label in the code. The multiboot_header will be copied by the linked to be above the rest of the ELF file, e.g., text section.\nBuilding Hello world Now we’re ready to actually implement the code that prints “Hello world!” on the screen (this is adapted from intermezzOS).\nglobal start section .text bits 32 ; By default, GRUB loads the kernel in 32-bit mode start: ; Print `Hello world!` on the screen by placing ASCII  ; characters in the VGA screen buffer that starts at 0xb8000  mov word [0xb8000], 0x0248 ; H  mov word [0xb8002], 0x0265 ; e  mov word [0xb8004], 0x026c ; l  mov word [0xb8006], 0x026c ; l  mov word [0xb8008], 0x026f ; o  mov word [0xb800a], 0x0220 ;  mov word [0xb800c], 0x0277 ; w  mov word [0xb800e], 0x026f ; o  mov word [0xb8010], 0x0272 ; r  mov word [0xb8012], 0x026c ; l  mov word [0xb8014], 0x0264 ; d  mov word [0xb8016], 0x0221 ; !  hlt ; Halt CPU  The code moves ASCII characters H, e, l, etc., into the VGA frame buffer and then halts the CPU with the hlt instruction.\nNow we’re ready to build and run this simple kernel. First, we compile the multiboot header:\nnasm -felf32 multiboot_header.asm -o multiboot_header.o Then compile the hello code (let’s put it into the boot.asmfile):\nnasm -felf32 boot.asm -o boot.o Then invoke a linker to build a final kernel ELF binary:\nld -m elf_i386 -n -T linker.ld -o kernel.bin boot.o multiboot_header.o And now you’re ready to boot with Qemu:\nqemu-system-x86_64 -kernel kernel.bin Debugging with GDB Now lets see how we can debug our kernel with GDB. In the same folder where you work on your kernel create a simple .gdbinit file\ntarget remote localhost:1234 symbol-file kernel.bin This file instructs GDB to connect to the localhost:1234 and load the symbol file for kernel.bin. Now we’re ready to start our debugging session. In one terminal start Qemu\nqemu-system-x86_64 -kernel kernel.bin -S -s In another terminal simply start gdb and the .gdbinit will connect it to the Qemu instance running your OS\ngdb Inside GDB you can set a breakpoint on the start label, e.g.\n(gdb) b start Breakpoint 1 at 0x100010 Now switch layout to regs or asm and hit c for continue. Note, you don’t get to immediately see your “Hello world” code as Qemu will executes BIOS.\n(gdb) layout regs (gdb) c You can see your assembly sequence and can single step through it with si\n(gdb) si Debugging tips You can always check if your multiboot header is correct by running\ngrub-file --is-x86-multiboot kernel.bin The grub-file is quiet but return 0 if it finds a header, and 1 otherwise. You can check for the return code with\necho $? You can change --is-x86-multiboot to --is-x86-multiboot2 for checking the multiboot2 specification.\nAutomation with Make It’s much more convenient to assemble all build commands in a simple Makefile\nkernel := kernel.bin linker_script := linker.ld assembly_source_files := $(wildcard *.asm) assembly_object_files := $(patsubst %.asm, build/%.o, $(assembly_source_files)) .PHONY: all clean kernel qemu qemu-gdb all: $(kernel) clean: - @rm -fr build *.o $(kernel) - @rm -f serial.log qemu: $(kernel) qemu-system-x86_64 -vga std -s -serial file:serial.log -kernel $(kernel) qemu-gdb: $(kernel) qemu-system-x86_64 -vga std -s -serial file:serial.log -S -kernel $(kernel) $(kernel): $(assembly_object_files) $(linker_script) ld -m elf_i386 -n -T $(linker_script) -o $(kernel) $(assembly_object_files) # compile assembly files build/%.o: %.asm @mkdir -p $(shell dirname $@) nasm -felf32 $Qemu: Booting a 64bit Kernel Remember, Qemu supports only the mutiboot v1 specification, and will only boot a 32bit ELF binary. Since most likely you will be building a 64bit kernel the -kernel flag to Qemu is a somewhat limited option. An alternative way to boot is to really go through the full boot protocol with a real boot loader that can boot our kernel from some kind of a storage device. The simplest way is to create a CD-ROM image that contains the GRUB loader and your kernel. Qemu will run the BIOS and the BIOS will follow the boot protocol loading GRUB the CD-ROM device. Then GRUB that supports both Multiboot v1 and v2 will load our 64bit kernel.\nTo create a bootable ISO, we’re going to use the grub2-mkrescue program that generates a GRUB rescue image. We first create a folder layout that will contain our kernel on disk, and then use grub2-mkrescue to create a rescue image.\nmkdir -p build/isofiles/boot/grub The -p flag to mkdir will make the directory we specify, as well as any directories missing in the path (-p stands for “parent” as in parent directories). In other words, this will make the build directory with the isofiles directory inside that has boot inside, and finally the grub directory inside of that.\nIn other words we are creating the following layout:\n├── build │ ├── boot.o │ ├── hello.iso │ ├── isofiles │ │ └── boot │ │ ├── grub │ │ │ └── grub.cfg │ │ └── kernel.bin Next, we create grub.cfg, a GRUB configuration file inside of that build/isofiles/boot/grub directory. The GRUB config file will instruct GRUB how to boot our kernel:\nset timeout=0 set default=0 menuentry \"hello\" { multiboot2 /boot/kernel.bin boot } Note that we set the default GRUB entry to 0 (that’s the only entry we have), and configure the timeout to be 0 seconds (after all we just want to boot immediately).\nOne additional detial here is that we switch from Multiboot v1 to v2, so we use a slightly different multiboot_header.asm file:\n; Multiboot 2 - Compliant Header ; https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html (Section 3.1.1) section .multiboot_header header_start: ; Multiboot macros to make a few lines later more readable  MULTIBOOT_PAGE_ALIGN\tequ 10 MULTIBOOT_HEADER_ARCH equ 0 ; 32-bit (protected) mode of i386  MULTIBOOT_HEADER_MAGIC\tequ 0xe85250d6 ; magic number  MULTIBOOT_CHECKSUM\tequ - (MULTIBOOT_HEADER_MAGIC + (header_end - header_start)) ; checksum  ; (magic number + checksum + flags should equal 0)  MULTIBOOT_TYPE\tequ 0 MULTIBOOT_FLAGS\tequ 0 MULTIBOOT_SIZE\tequ 8 ; This is the GRUB Multiboot header. A boot signature  dd MULTIBOOT_HEADER_MAGIC dd MULTIBOOT_HEADER_ARCH dd header_end - header_start ; Size of the Header  dd MULTIBOOT_CHECKSUM ; Required end tag  dw MULTIBOOT_TYPE dw MULTIBOOT_FLAGS dd MULTIBOOT_SIZE header_end: Again, don’t be shy to check the Multiboot Specification v2, Section 3.1.1 to see the exact meaning of all fields that we use above.\nNow don’t have to bother about compiling the 32bit kernel, and instead use normal 64bit ELF file.\nnasm -felf64 boot.asm -o build/boot.o nasm -felf64 multiboot_header.asm -o build/multiboot_header.o ld -n -T linker.ld -o build/kernel.bin build/boot.o build/multiboot_header.o Here we ask the linker to put the kernel.bin file inside boot.\nWe can use grub2-mkrescue to generate a bootable ISO image:\n$ grub2-mkrescue -o build/hello.iso build/isofiles The -o flag controls the output filename, which we choose to be build/hello.iso. And then we pass it the directory to make the ISO out of, which is the build/isofiles directory we just set up.\nThis will produce an build/hello.iso file with our kernel inside. Now we can pass this ISO file to QEMU\n$ qemu-system-x86_64 -cdrom build/hello.iso Booting off a USB stick Copy the ISO disk image to the USB stick (make sure to use correct device for the USB drive, otherwise you can overwrite your hard disk). You can use lsblk on Ubuntu to list block devices\nlsblk For me it’s /dev/sda or /dev/sdb but my laptop runs off an NVMe device, so for you /dev/sda may very well be your root device, not a USB!\nsudo dd if=build/hello.iso of=/dev/ bs=1MB sync Boot on baremetal from a Linux partition sudo cp build/kernel.bin /boot/ Add the following entry to the grub menu list. On a Linux machine this can be done by adding this to the /etc/grub.d/40_custom. You might adjust the root=‘hd0,2’ to reflect where your Linux root is on disk, e.g., maybe it’s on root=‘hd0,1’\nset timeout=30 menuentry \"Hello World\" { insmod ext2 set root='hd0,1' set kernel='/boot/kernel.bin' echo \"Loading ${kernel}...\" multiboot2 ${kernel} ${kernel} boot } Update grub\n sudo sudo update-grub2 Reboot and choose the “Hello World” entry. Make sure that you can see the grub menu list by editing /etc/default/grub making sure that GRUB_HIDDEN_TIMEOUT_QUIET is set to “false”.\n GRUB_HIDDEN_TIMEOUT_QUIET=false Source code The source code for this post can be found at hello-os master and qemu-kernel branches.\nResources   intermezzOS, an operating system for learning provides an excellent and detailed overview of how to boot into Rust (including printing the “Hello World!” discussed here.\n  A minimal Multiboot Kernel is a blog post that describes a minimal multiboot kernel.\n  How Does an Intel Processor Boot? is a good overview of the boot process on Intel CPUs.\n  Intel SGX Explained provides yet another, more in-depth overview of the boot process on Intel platforms.\n  linux-insides provides an overview of the Linux boot process.\n  ",
  "wordCount" : "2195",
  "inLanguage": "en",
  "datePublished": "2020-10-28T00:00:00Z",
  "dateModified": "2020-10-28T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Anton Burtsev"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mars-research.github.io/posts/2020/10/hello-world-on-bare-metal/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mars Research Group",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mars-research.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mars-research.github.io/" accesskey="h" title="Mars Research Group (Alt + H)">Mars Research Group</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mars-research.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://mars-research.github.io/publications" title="Publications">
                    <span>Publications</span>
                </a>
            </li>
            <li>
                <a href="https://mars-research.github.io/projects" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="https://mars-research.github.io/news" title="News">
                    <span>News</span>
                </a>
            </li>
            <li>
                <a href="https://mars-research.github.io/posts" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://mars-research.github.io/reading-group" title="Reading Group">
                    <span>Reading Group</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://mars-research.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://mars-research.github.io/posts/">Blog</a></div>
    <h1 class="post-title">
      Kernel Development with Qemu (Printing &#34;Hello World&#34; On Bare Metal)
    </h1>
    <div class="post-description">
      How to get started with kernel development on Qemu platform
    </div>
    <div class="post-meta">October 28, 2020&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Anton Burtsev&nbsp;|&nbsp;<a href="https://github.com/mars-research/mars-research.github.io/blob/main/content/posts/2020/10/hello-world-on-bare-metal.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> 
  <div class="post-content"><p>If you plan to start working on a new operating system kernel things get hard
fast&mdash;there is a ton of low-level hardware details you have to understand and
a number of design decisions you have to make (after all, why would you build
yet another kernel&mdash;you have to invent something new, right?).  Complexity is
intimidating. Nevertheless, if you take it step by step, the basics are simple.
And it&rsquo;s worth trying. We&rsquo;re sure you&rsquo;ll venture into your own kernel
story&mdash;multicore-scalability, security, safety, fast device access,</p>
<p>This post provides a minimal set of steps needed to print &ldquo;Hello world!&rdquo; on the
screen.</p>
<h2 id="qemu-the-fastest-way-to-start">Qemu: the Fastest Way to Start<a hidden class="anchor" aria-hidden="true" href="#qemu-the-fastest-way-to-start">#</a></h2>
<p>The fastest way to get started on a new kernel is to use a virtual machine like
Qemu. Note, we like Qemu the most because it is open source (if things go
wrong, you can actually debug what is going on), and good support on Linux
servers (we carry most of our development remotely in a baremetal datacenter,
and Qemu just works out of the box). Compared to running on real hardware
(which has a long reboot cycle, and limited debugging mechanisms), development
under a virtual machine, e.g., Qemu has a much quicker cycle and gives a ton of
debugging opportunities (e.g., attaching GDB, dumping page tables,
understanding triple faults, etc.).  Moreover, for serious kernel development,
the Qemu+KVM bundle provides performance that is nearly identical to bare metal
for most workloads, i.e., a nested page table slows you down by a couple
of percents on workloads that touch a lot of memory, e.g., a hash table, but
overall by running on Qemu+KVM you get a fair estimate of your system&rsquo;s
performance.</p>
<p>Qemu can boot a multiboot-compatible kernel with the (<code>-kernel</code>) option.
Multiboot is a general specification. This is convenient, it can be booted by
any multiboot-compatible boot loader, e.g., GRUB&mdash;this makes it convenient the
moment you are ready to test your kernel on real hardware you can boot it with
GRUB (see below).</p>
<p>The Multiboot specification requires that the kernel binary starts with a
special header. We will make this header in two steps: 1) we will use assembly
to create specific header constants (it&rsquo;s possible to make the header in C, but
what if you program your kernel in Rust?) and 2) we will use a linker script to
make sure that the header is placed exactly at the beginning of the kernel
binary.</p>
<h3 id="multiboot-header">Multiboot Header<a hidden class="anchor" aria-hidden="true" href="#multiboot-header">#</a></h3>
<p>A multiboot header is easy (the code is adapted from <a href="https://www.cs.vu.nl/~herbertb/misc/writingkernels.txt">&ldquo;Writing kernels that boot with Qemu and Grub&rdquo; tutorial by Herbert Boss</a> and it uses
the Intel assembly):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#75715e">; Multiboot v1 - Compliant Header for QEMU 
</span><span style="color:#75715e">; We use multiboot v1 since Qemu &#34;-kernel&#34; doesn&#39;t support 
</span><span style="color:#75715e">; multiboot v2
</span><span style="color:#75715e"></span>
<span style="color:#75715e">; This part MUST be 4-byte aligned, so we solve that issue using &#39;ALIGN 4&#39;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">ALIGN</span> <span style="color:#ae81ff">4</span>
<span style="color:#a6e22e">section</span> <span style="color:#66d9ef">.multiboot_header</span>
    <span style="color:#75715e">; Multiboot macros to make a few lines later more readable
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">MULTIBOOT_PAGE_ALIGN</span>	<span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">&lt;&lt;</span><span style="color:#ae81ff">0</span>
    <span style="color:#a6e22e">MULTIBOOT_MEMORY_INFO</span>	<span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">&lt;&lt;</span><span style="color:#ae81ff">1</span>                                         
    <span style="color:#66d9ef">MULTIBOOT_HEADER_MAGIC</span>	<span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">0x1BADB002</span>                                   <span style="color:#75715e">; magic number 
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">MULTIBOOT_HEADER_FLAGS</span>	<span style="color:#66d9ef">equ</span> <span style="color:#66d9ef">MULTIBOOT_PAGE_ALIGN</span> <span style="color:#960050;background-color:#1e0010">|</span> <span style="color:#66d9ef">MULTIBOOT_MEMORY_INFO</span> <span style="color:#75715e">; flags
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">MULTIBOOT_CHECKSUM</span>	<span style="color:#66d9ef">equ</span> - (<span style="color:#66d9ef">MULTIBOOT_HEADER_MAGIC</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">MULTIBOOT_HEADER_FLAGS</span>)  <span style="color:#75715e">; checksum 
</span><span style="color:#75715e"></span>                                <span style="color:#75715e">; (magic number + checksum + flags should equal 0)
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">; This is the GRUB Multiboot header. A boot signature
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">dd</span> <span style="color:#66d9ef">MULTIBOOT_HEADER_MAGIC</span>
    <span style="color:#a6e22e">dd</span> <span style="color:#66d9ef">MULTIBOOT_HEADER_FLAGS</span>
    <span style="color:#a6e22e">dd</span> <span style="color:#66d9ef">MULTIBOOT_CHECKSUM</span>

</code></pre></div><p>Here we first define several constants, e.g., <code>MULTIBOOT_PAGE_ALIGN</code>, <code>MULTIBOOT_MEMORY_INFO</code>,
<code>MULTIBOOT_HEADER_MAGIC</code>, combine them into <code>MULTIBOOT_HEADER_FLAGS</code> and <code>MULTIBOOT_CHECKSUM</code>, and
then define the header as three 4 byte values in the last three lines.</p>
<p>While this looks criptic in practice it&rsquo;s rather simple.
Go ahead and read the <a href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html">Multiboot Specification, Section 3.1.1</a>
to see which fields are put inside the header.</p>
<p>We can compile this with <code>nasm</code> like</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">nasm -felf32 multiboot_header.asm -o multiboot_header.o
</code></pre></div><h3 id="linker-script">Linker Script<a hidden class="anchor" aria-hidden="true" href="#linker-script">#</a></h3>
<p>Now we need to compile a kernel binary in such a way that the multiboot header appears as the first
section in the ELF file. For this we will use a linker scripts that instructs the linker to copy
sections from multiple files in a specific order:</p>
<pre tabindex="0"><code>ENTRY(start)

SECTIONS {
    . = 0x100000; /* Tells GRUB to load the kernel starting at the 1MB */

    .boot :
    {
        /* Ensure that the multiboot header is at the beginning */
        *(.multiboot_header)
    }

    .text :
    {
        *(.text)
    }

}
</code></pre><p>Here we specify that the kernel entry point will be the <code>start</code> label. The
bootloader that understand ELF format will load the kernel in memory (by the
way, we ask to load the kernel at address <code>0x100000</code>) and will jump to the
entry point specified in the ELF header. The linker will arrange that the ELF
entry point points to the <code>start</code> label in the code. The <code>multiboot_header</code>
will be copied by the linked to be above the rest of the ELF file, e.g., <code>text</code>
section.</p>
<h3 id="building-hello-world">Building Hello world<a hidden class="anchor" aria-hidden="true" href="#building-hello-world">#</a></h3>
<p>Now we&rsquo;re ready to actually implement the code that prints &ldquo;Hello world!&rdquo; on
the screen (this is adapted from <a href="https://intermezzos.github.io/book/first-edition/hello-world.html">intermezzOS</a>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">global</span> <span style="color:#66d9ef">start</span>

<span style="color:#a6e22e">section</span> <span style="color:#66d9ef">.text</span>
<span style="color:#a6e22e">bits</span> <span style="color:#ae81ff">32</span>    <span style="color:#75715e">; By default, GRUB loads the kernel in 32-bit mode
</span><span style="color:#75715e"></span><span style="color:#66d9ef">start</span>:
    
    <span style="color:#75715e">; Print `Hello world!` on the screen by placing ASCII 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">; characters in the VGA screen buffer that starts at 0xb8000
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8000</span>], <span style="color:#ae81ff">0x0248</span> <span style="color:#75715e">; H
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8002</span>], <span style="color:#ae81ff">0x0265</span> <span style="color:#75715e">; e
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8004</span>], <span style="color:#ae81ff">0x026c</span> <span style="color:#75715e">; l
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8006</span>], <span style="color:#ae81ff">0x026c</span> <span style="color:#75715e">; l
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8008</span>], <span style="color:#ae81ff">0x026f</span> <span style="color:#75715e">; o
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb800a</span>], <span style="color:#ae81ff">0x0220</span> <span style="color:#75715e">;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb800c</span>], <span style="color:#ae81ff">0x0277</span> <span style="color:#75715e">; w
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb800e</span>], <span style="color:#ae81ff">0x026f</span> <span style="color:#75715e">; o
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8010</span>], <span style="color:#ae81ff">0x0272</span> <span style="color:#75715e">; r
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8012</span>], <span style="color:#ae81ff">0x026c</span> <span style="color:#75715e">; l
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8014</span>], <span style="color:#ae81ff">0x0264</span> <span style="color:#75715e">; d
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8016</span>], <span style="color:#ae81ff">0x0221</span> <span style="color:#75715e">; !
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">hlt</span> <span style="color:#75715e">; Halt CPU 
</span><span style="color:#75715e"></span>
</code></pre></div><p>The code moves ASCII characters <code>H</code>, <code>e</code>, <code>l</code>, etc., into the VGA frame buffer and then halts
the CPU with the <code>hlt</code> instruction.</p>
<p>Now we&rsquo;re ready to build and run this simple kernel. First, we compile the multiboot header:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">nasm -felf32 multiboot_header.asm -o multiboot_header.o
</code></pre></div><p>Then compile the hello code (let&rsquo;s put it into the <code>boot.asm</code>file):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">nasm -felf32 boot.asm -o boot.o
</code></pre></div><p>Then invoke a linker to build a final kernel ELF binary:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">ld -m elf_i386 -n -T linker.ld -o kernel.bin boot.o multiboot_header.o
</code></pre></div><p>And now you&rsquo;re ready to boot with Qemu:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">qemu-system-x86_64 -kernel kernel.bin
</code></pre></div><h3 id="debugging-with-gdb">Debugging with GDB<a hidden class="anchor" aria-hidden="true" href="#debugging-with-gdb">#</a></h3>
<p>Now lets see how we can debug our kernel with GDB. In the same folder where you work on your
kernel create a simple <code>.gdbinit</code> file</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">target remote localhost:1234
symbol-file kernel.bin
</code></pre></div><p>This file instructs GDB to connect to the <code>localhost:1234</code> and load the symbol file for <code>kernel.bin</code>.
Now we&rsquo;re ready to start our debugging session. In one terminal start Qemu</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">qemu-system-x86_64 -kernel kernel.bin -S -s
</code></pre></div><p>In another terminal simply start gdb and the <code>.gdbinit</code> will connect it to the Qemu instance
running your OS</p>
<pre tabindex="0"><code>gdb
</code></pre><p>Inside GDB you can set a breakpoint on the <code>start</code> label, e.g.</p>
<pre tabindex="0"><code>(gdb) b start
Breakpoint 1 at 0x100010
</code></pre><p>Now switch layout to <code>regs</code> or <code>asm</code> and hit <code>c</code> for continue. Note, you don&rsquo;t get to immediately
see your &ldquo;Hello world&rdquo; code as Qemu will executes BIOS.</p>
<pre tabindex="0"><code>(gdb) layout regs
(gdb) c
</code></pre><p>You can see your assembly sequence and can single step through it with <code>si</code></p>
<pre tabindex="0"><code>(gdb) si
</code></pre><h3 id="debugging-tips">Debugging tips<a hidden class="anchor" aria-hidden="true" href="#debugging-tips">#</a></h3>
<p>You can always check if your multiboot header is correct by running</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">grub-file --is-x86-multiboot kernel.bin
</code></pre></div><p>The <code>grub-file</code> is quiet but return 0 if it finds a header, and 1 otherwise.
You can check for the return code with</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">echo $?
</code></pre></div><p>You can change <code>--is-x86-multiboot</code> to <code>--is-x86-multiboot2</code> for checking the
multiboot2 specification.</p>
<h3 id="automation-with-make">Automation with Make<a hidden class="anchor" aria-hidden="true" href="#automation-with-make">#</a></h3>
<p>It&rsquo;s much more convenient to assemble all build commands in a simple Makefile</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-make" data-lang="make">kernel <span style="color:#f92672">:=</span> kernel.bin

linker_script <span style="color:#f92672">:=</span> linker.ld
assembly_source_files <span style="color:#f92672">:=</span> <span style="color:#66d9ef">$(</span>wildcard *.asm<span style="color:#66d9ef">)</span>
assembly_object_files <span style="color:#f92672">:=</span> <span style="color:#66d9ef">$(</span>patsubst %.asm, build/%.o, <span style="color:#66d9ef">$(</span>assembly_source_files<span style="color:#66d9ef">))</span>

<span style="color:#a6e22e">.PHONY</span><span style="color:#f92672">:</span> all clean kernel qemu qemu-gdb

<span style="color:#a6e22e">all</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">$(</span>kernel<span style="color:#66d9ef">)</span>

<span style="color:#a6e22e">clean</span><span style="color:#f92672">:</span>
	- @rm -fr build *.o <span style="color:#66d9ef">$(</span>kernel<span style="color:#66d9ef">)</span>
	- @rm -f serial.log

<span style="color:#a6e22e">qemu</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">$(</span>kernel<span style="color:#66d9ef">)</span>
	qemu-system-x86_64 -vga std -s -serial file:serial.log -kernel <span style="color:#66d9ef">$(</span>kernel<span style="color:#66d9ef">)</span>

<span style="color:#a6e22e">qemu-gdb</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">$(</span>kernel<span style="color:#66d9ef">)</span>
	qemu-system-x86_64 -vga std -s -serial file:serial.log -S -kernel <span style="color:#66d9ef">$(</span>kernel<span style="color:#66d9ef">)</span>

<span style="color:#a6e22e">$(kernel)</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">$(</span>assembly_object_files<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>linker_script<span style="color:#66d9ef">)</span>
	ld -m elf_i386 -n -T <span style="color:#66d9ef">$(</span>linker_script<span style="color:#66d9ef">)</span> -o <span style="color:#66d9ef">$(</span>kernel<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>assembly_object_files<span style="color:#66d9ef">)</span>

<span style="color:#75715e"># compile assembly files
</span><span style="color:#75715e"></span><span style="color:#a6e22e">build/%.o</span><span style="color:#f92672">:</span> %.asm
	@mkdir -p <span style="color:#66d9ef">$(</span>shell dirname $@<span style="color:#66d9ef">)</span>
	nasm -felf32 $&lt; -o $@

</code></pre></div><h2 id="qemu-booting-a-64bit-kernel">Qemu: Booting a 64bit Kernel<a hidden class="anchor" aria-hidden="true" href="#qemu-booting-a-64bit-kernel">#</a></h2>
<p>Remember, Qemu supports only the mutiboot v1 specification, and will only
boot a 32bit ELF binary. Since most likely you will be building a 64bit kernel the <code>-kernel</code>
flag to Qemu is a somewhat limited option. An alternative way to boot is to really go through the full
boot protocol with a real boot loader that can boot our kernel from some kind of a storage device.
The simplest way is to create a CD-ROM image that
contains the GRUB loader and your kernel. Qemu will run the BIOS and the BIOS will follow the
boot protocol loading GRUB the CD-ROM device. Then GRUB that supports both Multiboot v1 and v2
will load our 64bit kernel.</p>
<p>To create a bootable ISO, we&rsquo;re going to use the <code>grub2-mkrescue</code> program that
generates a GRUB rescue image.  We first create a folder layout that will
contain our kernel on disk, and then use  <code>grub2-mkrescue</code> to create a rescue
image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">mkdir -p build/isofiles/boot/grub
</code></pre></div><p>The -p flag to mkdir will make the directory we specify, as well as any
directories missing in the path (<code>-p</code> stands for &ldquo;parent&rdquo; as in parent directories).
In other words, this will make the <code>build</code> directory with the <code>isofiles</code> directory inside
that has <code>boot</code> inside, and finally the <code>grub</code> directory inside of that.</p>
<p>In other words we are creating the following layout:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">├── build
│   ├── boot.o
│   ├── hello.iso
│   ├── isofiles
│   │   └── boot
│   │       ├── grub
│   │       │   └── grub.cfg
│   │       └── kernel.bin
</code></pre></div><p>Next, we create <code>grub.cfg</code>, a GRUB configuration file inside of that build/isofiles/boot/grub directory. The GRUB
config file will instruct GRUB how to boot our kernel:</p>
<pre tabindex="0"><code>set timeout=0
set default=0

menuentry &quot;hello&quot; {
    multiboot2 /boot/kernel.bin
    boot
}

</code></pre><p>Note that we set the <code>default</code> GRUB entry to 0 (that&rsquo;s the only entry we have), and configure the <code>timeout</code> to be 0
seconds (after all we just want to boot immediately).</p>
<p>One additional detial here is that we switch from Multiboot v1 to v2, so we use a slightly different <code>multiboot_header.asm</code> file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#75715e">; Multiboot 2 - Compliant Header
</span><span style="color:#75715e">; https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html (Section 3.1.1)
</span><span style="color:#75715e"></span><span style="color:#a6e22e">section</span> <span style="color:#66d9ef">.multiboot_header</span>
header_start:
    <span style="color:#75715e">; Multiboot macros to make a few lines later more readable
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">MULTIBOOT_PAGE_ALIGN</span>	<span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">&lt;&lt;</span><span style="color:#ae81ff">0</span>
    <span style="color:#a6e22e">MULTIBOOT_HEADER_ARCH</span>       <span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">0</span>         <span style="color:#75715e">; 32-bit (protected) mode of i386
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">MULTIBOOT_HEADER_MAGIC</span>	<span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">0xe85250d6</span>          <span style="color:#75715e">; magic number
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">MULTIBOOT_CHECKSUM</span>	<span style="color:#66d9ef">equ</span> - (<span style="color:#66d9ef">MULTIBOOT_HEADER_MAGIC</span> <span style="color:#960050;background-color:#1e0010">+</span> (<span style="color:#66d9ef">header_end</span> - <span style="color:#66d9ef">header_start</span>))  <span style="color:#75715e">; checksum
</span><span style="color:#75715e"></span>                                                        <span style="color:#75715e">; (magic number + checksum + flags should equal 0)
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">MULTIBOOT_TYPE</span>		<span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">0</span>
    <span style="color:#a6e22e">MULTIBOOT_FLAGS</span>		<span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">0</span>
    <span style="color:#a6e22e">MULTIBOOT_SIZE</span>		<span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">8</span>

    <span style="color:#75715e">; This is the GRUB Multiboot header. A boot signature
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">dd</span> <span style="color:#66d9ef">MULTIBOOT_HEADER_MAGIC</span>
    <span style="color:#a6e22e">dd</span> <span style="color:#66d9ef">MULTIBOOT_HEADER_ARCH</span>
    <span style="color:#a6e22e">dd</span> <span style="color:#66d9ef">header_end</span> - <span style="color:#66d9ef">header_start</span> <span style="color:#75715e">; Size of the Header
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">dd</span> <span style="color:#66d9ef">MULTIBOOT_CHECKSUM</span>

    <span style="color:#75715e">; Required end tag
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">dw</span> <span style="color:#66d9ef">MULTIBOOT_TYPE</span>
    <span style="color:#a6e22e">dw</span> <span style="color:#66d9ef">MULTIBOOT_FLAGS</span>
    <span style="color:#a6e22e">dd</span> <span style="color:#66d9ef">MULTIBOOT_SIZE</span>
header_end:
</code></pre></div><p>Again, don&rsquo;t be shy to check the <a href="https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html">Multiboot Specification v2, Section 3.1.1</a>
to see the exact meaning of all fields that we use above.</p>
<p>Now don&rsquo;t have to bother about compiling the 32bit kernel, and instead use normal 64bit ELF file.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">nasm -felf64 boot.asm -o build/boot.o
nasm -felf64 multiboot_header.asm -o build/multiboot_header.o
ld -n -T linker.ld -o build/kernel.bin  build/boot.o  build/multiboot_header.o
</code></pre></div><p>Here we ask the linker to put the <code>kernel.bin</code> file inside <code>boot</code>.</p>
<p>We can use <code>grub2-mkrescue</code> to generate a bootable ISO image:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ grub2-mkrescue -o build/hello.iso build/isofiles
</code></pre></div><p>The -o flag controls the output filename, which we choose to be <code>build/hello.iso</code>. And then we pass it the directory to make the ISO out of, which is the <code>build/isofiles</code> directory we just set up.</p>
<p>This will produce an <code>build/hello.iso</code> file with our kernel inside. Now we can pass this ISO file to QEMU</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ qemu-system-x86_64 -cdrom build/hello.iso
</code></pre></div><h2 id="booting-off-a-usb-stick">Booting off a USB stick<a hidden class="anchor" aria-hidden="true" href="#booting-off-a-usb-stick">#</a></h2>
<p>Copy the ISO disk image to the USB stick (make sure to use correct device for the
USB drive, otherwise you can overwrite your hard disk). You can use lsblk on Ubuntu
to list block devices</p>
<pre tabindex="0"><code>lsblk
</code></pre><p>For me it&rsquo;s <code>/dev/sda</code> or <code>/dev/sdb</code> but my laptop runs off an NVMe device, so for you
<code>/dev/sda</code> may very well be your root device, not a USB!</p>
<pre tabindex="0"><code>sudo dd if=build/hello.iso of=/dev/&lt;your_usb_drive&gt; bs=1MB
sync
</code></pre><h3 id="boot-on-baremetal-from-a-linux-partition">Boot on baremetal from a Linux partition<a hidden class="anchor" aria-hidden="true" href="#boot-on-baremetal-from-a-linux-partition">#</a></h3>
<pre tabindex="0"><code>sudo cp build/kernel.bin /boot/
</code></pre><p>Add the following entry to the grub menu list. On a Linux machine this can
be done by adding this to the /etc/grub.d/40_custom. You might adjust the
root=&lsquo;hd0,2&rsquo; to reflect where your Linux root is on disk, e.g., maybe it&rsquo;s on
root=&lsquo;hd0,1&rsquo;</p>
<pre tabindex="0"><code>set timeout=30
menuentry &quot;Hello World&quot; {
    insmod ext2
    set root='hd0,1'
    set kernel='/boot/kernel.bin'
    echo &quot;Loading ${kernel}...&quot;
    multiboot2 ${kernel} ${kernel}
    boot
}
</code></pre><p>Update grub</p>
<pre tabindex="0"><code>  sudo sudo update-grub2
</code></pre><p>Reboot and choose the &ldquo;Hello World&rdquo; entry. Make sure that you can see the grub menu
list by editing /etc/default/grub making sure that GRUB_HIDDEN_TIMEOUT_QUIET is
set to &ldquo;false&rdquo;.</p>
<pre tabindex="0"><code>  GRUB_HIDDEN_TIMEOUT_QUIET=false
</code></pre><h2 id="source-code">Source code<a hidden class="anchor" aria-hidden="true" href="#source-code">#</a></h2>
<p>The source code for this post can be found at  <a href="https://github.com/mars-research/hello-os">hello-os</a> <code>master</code> and
<code>qemu-kernel</code> branches.</p>
<h2 id="resources">Resources<a hidden class="anchor" aria-hidden="true" href="#resources">#</a></h2>
<ul>
<li>
<p><a href="https://intermezzos.github.io/book/first-edition/booting-up.html">intermezzOS, an operating system for learning</a> provides
an excellent and detailed overview of how to boot into Rust (including printing the &ldquo;Hello World!&rdquo; discussed here.</p>
</li>
<li>
<p><a href="https://os.phil-opp.com/multiboot-kernel/">A minimal Multiboot Kernel</a> is a blog post that describes a minimal multiboot kernel.</p>
</li>
<li>
<p><a href="https://binarydebt.wordpress.com/2018/10/06/how-does-an-x86-processor-boot/">How Does an Intel Processor Boot?</a> is a good
overview of the boot process on Intel CPUs.</p>
</li>
<li>
<p><a href="https://eprint.iacr.org/2016/086.pdf">Intel SGX Explained</a> provides yet another, more in-depth overview of the boot process
on Intel platforms.</p>
</li>
<li>
<p><a href="https://0xax.gitbooks.io/linux-insides/content/Booting/">linux-insides</a> provides an overview of the Linux boot process.</p>
</li>
</ul>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://mars-research.github.io/">Mars Research Group</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
