<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Debugging QEMU/KVM Setup If Something Goes Wrong (e.g., Support for 1GB Pages) | Mars Research Group</title>
<meta name="keywords" content="">
<meta name="description" content="In our previous projects, we always did all development on real hardware. For example, LXDs and LVDs required baremetal speed of the cache-coherence protocol and support for nested virtualization (both systems use hardware-supported virtualization). So development under QEMU looked unrealistic. Well, maybe we need to explore more. KVM supports nested virtualization, but we needed support for features like extended page table (EPT) switching with VMFUNC. In the end, we were reluctant to take this approach.">
<meta name="author" content="Vikram Narayanan">
<link rel="canonical" href="https://mars-research.github.io/posts/2020/11/qemu-kvm-1gb-pages/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css" integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://mars-research.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mars-research.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mars-research.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mars-research.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://mars-research.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Debugging QEMU/KVM Setup If Something Goes Wrong (e.g., Support for 1GB Pages)" />
<meta property="og:description" content="In our previous projects, we always did all development on real hardware. For example, LXDs and LVDs required baremetal speed of the cache-coherence protocol and support for nested virtualization (both systems use hardware-supported virtualization). So development under QEMU looked unrealistic. Well, maybe we need to explore more. KVM supports nested virtualization, but we needed support for features like extended page table (EPT) switching with VMFUNC. In the end, we were reluctant to take this approach." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mars-research.github.io/posts/2020/11/qemu-kvm-1gb-pages/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-01T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-11-01T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Debugging QEMU/KVM Setup If Something Goes Wrong (e.g., Support for 1GB Pages)"/>
<meta name="twitter:description" content="In our previous projects, we always did all development on real hardware. For example, LXDs and LVDs required baremetal speed of the cache-coherence protocol and support for nested virtualization (both systems use hardware-supported virtualization). So development under QEMU looked unrealistic. Well, maybe we need to explore more. KVM supports nested virtualization, but we needed support for features like extended page table (EPT) switching with VMFUNC. In the end, we were reluctant to take this approach."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blog",
      "item": "https://mars-research.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Debugging QEMU/KVM Setup If Something Goes Wrong (e.g., Support for 1GB Pages)",
      "item": "https://mars-research.github.io/posts/2020/11/qemu-kvm-1gb-pages/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Debugging QEMU/KVM Setup If Something Goes Wrong (e.g., Support for 1GB Pages)",
  "name": "Debugging QEMU\/KVM Setup If Something Goes Wrong (e.g., Support for 1GB Pages)",
  "description": "In our previous projects, we always did all development on real hardware. For example, LXDs and LVDs required baremetal speed of the cache-coherence protocol and support for nested virtualization (both systems use hardware-supported virtualization). So development under QEMU looked unrealistic. Well, maybe we need to explore more. KVM supports nested virtualization, but we needed support for features like extended page table (EPT) switching with VMFUNC. In the end, we were reluctant to take this approach.",
  "keywords": [
    
  ],
  "articleBody": "In our previous projects, we always did all development on real hardware. For example, LXDs and LVDs required baremetal speed of the cache-coherence protocol and support for nested virtualization (both systems use hardware-supported virtualization). So development under QEMU looked unrealistic. Well, maybe we need to explore more. KVM supports nested virtualization, but we needed support for features like extended page table (EPT) switching with VMFUNC. In the end, we were reluctant to take this approach.\nBut our most recent project, RedLeaf, is a new operating system implemented from scratch in Rust. This was the first time we used QEMU/KVM pair for development and found it extremely effective. Developing OS kernels under QEMU/KVM has a much quicker development cycle and gives a ton of debugging opportunities (e.g., attaching GDB, dumping page tables from QEMU, understanding triple faults, etc.). Plus it removes an extremely annoying long reboot cycle.\nWe will describe what we’ve learned in a collection of posts and hopefully, our lessons are useful to others. It took us some time to debug several things that did not work as expected when run on top of QEMU/KVM. Here, we describe our experience of debugging 1GB page support with KVM.\nSpoiler: our bug is trivial, we just did not pass the correct CPU model as an argument. So if you simply want to get it running scroll to the bottom. Our goal with this post is to share the tricks that allow us to debug similar issues with the QEMU setup.\nThe problem We started our development with a 3 level pagetable with 2MiB hugepages. Later, we wanted more memory and decided to support huge pagetables (1GiB pages).\nHere is our pagetable setup, trying to direct-map the first 32GiBs of memory:\nsetup_huge_page_tables: ; map first P4 entry to P3 table mov rax, hp3_table or rax, 0b11 ; present + writable mov [hp4_table], rax ;map each P3 entry to a huge 1GiB page mov ecx, 0 ; counter variable .map_hp3_table: ; map ecx-th P3 entry to a huge page that starts at address 1GiB*ecx mov rax, 1 \u003c\u003c 30 ; 1GiB mul ecx ; start address of ecx-th page shl rdx, 32 or rax, rdx or rax, 0b10000011 ; present + writable + huge mov [hp3_table + ecx * 8], rax ; map ecx-th entry inc ecx ; increase counter cmp ecx, 0x20 ; if counter == 32, 32 entries in P3 table is mapped jne .map_hp3_table ; else map the next entry ; Apic regions would belong in the first few gigabytes ret section .bss hp4_table: resb 4096 hp3_table: resb 4096 With this boot-time pagetable, everything was good when we run it on bare-metal, but things started to break under QEMU/KVM. All we had access to was an internal error from KVM and a register dump.\nKVM internal error. Suberror: 1 emulation failure EAX=80000011 EBX=00000000 ECX=c0000080 EDX=00000000 ESI=00000000 EDI=00000000 EBP=00000000 ESP=01bfa000 EIP=00133025 EFL=00010086 [--S--P-] CPL=0 II=0 A20=1 SMM=0 HLT=0 ES =0018 00000000 ffffffff 00c09300 DPL=0 DS [-WA] CS =0010 00000000 ffffffff 00c09b00 DPL=0 CS32 [-RA] SS =0018 00000000 ffffffff 00c09300 DPL=0 DS [-WA] DS =0018 00000000 ffffffff 00c09300 DPL=0 DS [-WA] FS =0018 00000000 ffffffff 00c09300 DPL=0 DS [-WA] GS =0018 00000000 ffffffff 00c09300 DPL=0 DS [-WA] LDT=0000 00000000 0000ffff 00008200 DPL=0 LDT TR =0000 00000000 0000ffff 00008b00 DPL=0 TSS64-busy GDT= 0000000000100018 0000000f IDT= 0000000000000000 00000000 CR0=80000011 CR2=0000000000000000 CR3=0000000000bf8000 CR4=00000020 DR0=0000000000000000 DR1=0000000000000000 DR2=0000000000000000 DR3=0000000000000000 DR6=00000000ffff0ff0 DR7=0000000000000400 EFER=0000000000000500 The program counter was pointing to an instruction which accesses the VGA buffer\n133025: 66 c7 05 00 80 0b 00 48 02 movw $0x248,0xb8000(%rip) At this point, what can we do to debug the crash? We were kind of lost, why VGA buffer, what went wrong?\nStep 1: Enable KVM tracing We start debugging by enabling KVM tracing with Linux tracepoints. [Linux tracepoints] (https://www.kernel.org/doc/html/latest/trace/tracepoints.html) are a lightweight instrumentation facility embedded in the Linux kernel. One can dynamically enable these tracepoints by registering a function that would be called when the tracepoint is executed.\nKVM Code has a lot of tracepoints for instrumenting various events. The list of tracepoints could be obtained by running perf list as shown below.\n$ sudo perf list | grep kvm ... kvm:kvm_emulate_insn [Tracepoint event] kvm:kvm_enter_smm [Tracepoint event] kvm:kvm_entry [Tracepoint event] kvm:kvm_eoi [Tracepoint event] kvm:kvm_exit [Tracepoint event] kvm:kvm_fast_mmio [Tracepoint event] kvm:kvm_fpu [Tracepoint event] kvm:kvm_halt_poll_ns [Tracepoint event] ... trace-cmd offers a set of tools to trace and collect these events.\nLet’s run with all kvm tracepoints enabled\nsudo trace-cmd record -b 20000 -e kvm From the dumped report,\nsudo trace-cmd report \u003e trace-cmd.txt we have some more details\nqemu-system-x86-31218 [000] 159269.806542: kvm_exit: reason EPT_MISCONFIG rip 0x133025 info 0 0 qemu-system-x86-31218 [000] 159269.806546: kvm_emulate_insn: 0:133025: ec qemu-system-x86-31218 [000] 159269.806547: kvm_emulate_insn: 0:133025: ec FAIL qemu-system-x86-31218 [000] 159269.806548: kvm_userspace_exit: reason KVM_EXIT_INTERNAL_ERROR (17) qemu-system-x86-31218 [000] 159269.806548: kvm_fpu: unload qemu-system-x86-31215 [007] 159325.605844: kvm_hv_stimer_cleanup: vcpu_id 0 timer 0 qemu-system-x86-31215 [007] 159325.605852: kvm_hv_stimer_cleanup: vcpu_id 0 timer 1 qemu-system-x86-31215 [007] 159325.605852: kvm_hv_stimer_cleanup: vcpu_id 0 timer 2 qemu-system-x86-31215 [007] 159325.605853: kvm_hv_stimer_cleanup: vcpu_id 0 timer 3 Well, grepping KVM_EXIT_INTERNAL_ERROR did not give us much information. But what caught the eye was that the instruction dump at rip was not what we see in objdump. So, we tried looking into the previous kvm_emulate_insn logs in the trace report to see how it is handled.\nBelow is our previous instance of emulate_insn trace.\nqemu-system-x86-31218 [000] 159269.805554: kvm_exit: reason IO_INSTRUCTION rip 0xa962 info 1770008 0 qemu-system-x86-31218 [000] 159269.805555: kvm_emulate_insn: f0000:a962: ec qemu-system-x86-31218 [000] 159269.805555: kvm_userspace_exit: reason KVM_EXIT_IO (2) From the above, it looks like kvm seem to have failed to fetch the instructions at our crashed rip (0x131025).\nThe kvm_emulate_insn trace is located at arch/x86/kvm/x86.c.\nThe exit reason is an EPT misconfiguration.\nqemu-system-x86-31218 [000] 159269.806542: kvm_exit: reason EPT_MISCONFIG rip 0x133025 info 0 0 and the request for emulation originated from here: handle_ept_misconfig which matches with our trace log.\nstatic int handle_ept_misconfig(struct kvm_vcpu *vcpu) { ... ret = handle_mmio_page_fault(vcpu, gpa, true); if (likely(ret == RET_MMIO_PF_EMULATE)) return x86_emulate_instruction(vcpu, gpa, 0, NULL, 0) == EMULATE_DONE; ... From arch/x86/kvm/x86.c\nint x86_emulate_instruction(struct kvm_vcpu *vcpu, unsigned long cr2, int emulation_type, void *insn, int insn_len) { struct x86_emulate_ctxt *ctxt = \u0026vcpu-\u003earch.emulate_ctxt; ... if (!(emulation_type \u0026 EMULTYPE_NO_DECODE)) { init_emulate_ctxt(vcpu); ... r = x86_decode_insn(ctxt, insn, insn_len); trace_kvm_emulate_insn_start(vcpu); Step 2: Taking a closer look at function arguments with Systemtap We want to understand what goes wrong in decoding the instruction at our faulting rip. For example, we may want to peek into the arguments to x86_decode_insn function to observe insn or its return value.\nOne way is to modify the kernel sources and add more debugging information in these functions. But that’s quite an invasive change. Instead, we use systemtap, a non-invasive way to attach probes at call and return sites for various kernel functions without modifying the kernel sources.\nSystemtap offers a nice commandline interface and a scripting language using which one can attach call/return probes to kernel functions. Additionally, it offers guru mode - where you can place embedded C blocks that can use kernel datastructures and functions.\nThe code flow of x86_decode_insn in our scenario is:\nIn the above graph, gva_to_gpa and is a function pointer which dynamically changes based on the context we run the guest on. Instead of trying to dig through the code to resolve it, we can run systemtap to dynamically figure out which gva_to_gpa pointer is mapped.\nAlso, to understand if address translation happens correctly, we monitored both these calls: kvm_fetch_guest_virt and kvm_vcpu_read_guest_page.\nHere is the systemtap script we use to stick a probe at call-site for these functions.\nglobal count = 0 probe module(\"kvm\").function(\"kvm_fetch_guest_virt\") { printf(\"%s eip 0x%08x, addr: 0x%08x, bytes: %d\\n\", ppfunc(), $ctxt-\u003eeip, $addr, $bytes); if (count == 0) { printf(\"fp_gva_to_gpa: %x\\n\", print_fp($ctxt)); count++; } // We want to know the gva_to_gpa when our guest is at this rip if ($addr == 0x133025) { printf(\"fp_gva_to_gpa: %x\\n\", print_fp($ctxt)); } } probe module(\"kvm\").function(\"kvm_vcpu_read_guest_page\") { printf(\" -%s =\u003e gfn 0x%08x\\n\", ppfunc(), $gfn); } Running this by logging the output to a file,\nsudo stap -v ./kvm.stp -o kvm_stap.log Here is what we have,\nkvm_fetch_guest_virt eip 0x0000cfa6, addr: 0x000fcfa6, bytes: 15 fp_gva_to_gpa: ffffffffa04416e0\t// This is what gva_to_gpa points to at the beginning -kvm_vcpu_read_guest_page =\u003e gfn 0x000000fc ... kvm_fetch_guest_virt eip 0x00133025, addr: 0x00133025, bytes: 15 fp_gva_to_gpa: ffffffffa0448660\t// This is what gva_to_gpa points to when we hit our bug The log shows that for the offending address, we see the record for kvm_fetch_guest_virt, but we do not see any for kvm_vcpu_read_guest_page, which means the our gva_to_gpa likely returned an error.\n/* used for instruction fetching */ static int kvm_fetch_guest_virt(struct x86_emulate_ctxt *ctxt, gva_t addr, void *val, unsigned int bytes, struct x86_exception *exception) { struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt); u32 access = (kvm_x86_ops-\u003eget_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0; unsigned offset; int ret; /* Inline kvm_read_guest_virt_helper for speed. */ gpa_t gpa = vcpu-\u003earch.walk_mmu-\u003egva_to_gpa(vcpu, addr, access|PFERR_FETCH_MASK, exception); if (unlikely(gpa == UNMAPPED_GVA)) return X86EMUL_PROPAGATE_FAULT; offset = addr \u0026 (PAGE_SIZE-1); if (WARN_ON(offset + bytes \u003e PAGE_SIZE)) bytes = (unsigned)PAGE_SIZE - offset; ret = kvm_vcpu_read_guest_page(vcpu, gpa \u003e\u003e PAGE_SHIFT, val, offset, bytes); if (unlikely(ret \u003c 0)) return X86EMUL_IO_NEEDED; return X86EMUL_CONTINUE; } From kallsyms, we can get the actual functions the gva_to_gpa functions pointers point to.\n$ sudo grep -e ffffffffa04416e0 -e ffffffffa0448660 /proc/kallsyms ffffffffa04416e0 t nonpaging_gva_to_gpa [kvm] ffffffffa0448660 t paging64_gva_to_gpa [kvm] During initialization, paging is turned off, so the function pointer is pointing to nonpaging_gva_to_gpa and when paging is turned on it points to paging64_gva_to_gpa. So, at our offending address, paging64_gva_to_gpa likely returns a failure.\nAll gva_to_gpa helpers are templatized in the file paging_tmpl.h. paging64_gva_to_gpa is nothing but a wrapper around paging64_walk_addr which inturn is a wrapper to paging64_walk_addr_generic which walks the relevant pagetable.\nAdding a return probe at this function in the systemtap script would give us the return value.\nglobal ret_active = 0 probe module(\"kvm\").function(\"paging64_walk_addr_generic\") { if ($addr == 0x00133025) { printf(\"Walking: %s\\n\", $$parms); ret_active = 1; } } probe module(\"kvm\").function(\"paging64_walk_addr_generic\").return { if (ret_active \u003e 0) { printf(\"return: %s\\n\", $$return); } } This gives us:\nWalking: walker=0xffff88140cf07a50 vcpu=0xffff882820b48000 mmu=0xffff882820b48300 addr=0x133025 access=0x10 return: return=0x0 Step 3: Enable even more KVM tracing The function (paging64_walk_addr_generic) returns 1 if it has found a valid mapping and 0 otherwise (in case of an error). From systemtap log, we see a failure in address walk, but we do not know yet what happened.\nFortunately, there are more tracepoints in the page walk code. Also, from perf list we have a bunch of kvm_mmu tracepoints.\n$ sudo perf list | grep kvmmmu ... kvmmmu:kvm_mmu_set_dirty_bit [Tracepoint event] kvmmmu:kvm_mmu_set_spte [Tracepoint event] kvmmmu:kvm_mmu_spte_requested [Tracepoint event] kvmmmu:kvm_mmu_sync_page [Tracepoint event] kvmmmu:kvm_mmu_unsync_page [Tracepoint event] kvmmmu:kvm_mmu_walker_error [Tracepoint event] ... By enabling the tracepoints in paging64_walk_addr_generic,\nsudo trace-cmd record -b 20000 -e kvm -e kvm_mmu_pagetable_walk -e kvm_mmu_paging_element -e kvm_mmu_walker_error we have more information about the error:\nqemu-system-x86-31218 [000] 159269.806542: kvm_exit: reason EPT_MISCONFIG rip 0x133025 info 0 0 qemu-system-x86-31218 [000] 159269.806544: kvm_mmu_pagetable_walk: addr 133025 pferr 10 F qemu-system-x86-31218 [000] 159269.806545: kvm_mmu_paging_element: pte bf9023 level 4 qemu-system-x86-31218 [000] 159269.806545: kvm_mmu_paging_element: pte a3 level 3 qemu-system-x86-31218 [000] 159269.806546: kvm_mmu_walker_error: pferr 9 P|RSVD qemu-system-x86-31218 [000] 159269.806546: kvm_emulate_insn: 0:133025: ec qemu-system-x86-31218 [000] 159269.806547: kvm_emulate_insn: 0:133025: ec FAIL qemu-system-x86-31218 [000] 159269.806548: kvm_userspace_exit: reason KVM_EXIT_INTERNAL_ERROR (17) Pagetable organization Before decoding the error, let’s take a quick look at our pagetable organization. We have just two levels (level4 and level3) From the log, the walk was successful for level4 table and while walking level3 we get an error which hints that the reserved bit is set on the level3 entry.\nstatic int FNAME(walk_addr_generic)(struct guest_walker *walker, struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, gva_t addr, u32 access) { ... trace_kvm_mmu_pagetable_walk(addr, access); do { ... if (unlikely(is_rsvd_bits_set(mmu, pte, walker-\u003elevel))) { errcode = PFERR_RSVD_MASK | PFERR_PRESENT_MASK; goto error; } ... } while (!is_last_gpte(mmu, walker-\u003elevel, pte)); error: ... trace_kvm_mmu_walker_error(walker-\u003efault.error_code); return 0; } The check for reserved bit is happening here\nstatic bool __is_rsvd_bits_set(struct rsvd_bits_validate *rsvd_check, u64 pte, int level) { int bit7 = (pte \u003e\u003e 7) \u0026 1, low6 = pte \u0026 0x3f; return (pte \u0026 rsvd_check-\u003ersvd_bits_mask[bit7][level-1]) | ((rsvd_check-\u003ebad_mt_xwr \u0026 (1ull \u003c\u003c low6)) != 0); } In our pagetable entry, we set bit7 in the level3 entry for enabling 1GiB pages. With those inputs, the expression above expands to rsvd_bits_mask[1][2]. The mask is set in __reset_rsvds_bits_mask.\nFrom arch/x86/kvm/mmu.c\nstatic void __reset_rsvds_bits_mask(struct kvm_vcpu *vcpu, struct rsvd_bits_validate *rsvd_check, int maxphyaddr, int level, bool nx, bool gbpages, bool pse, bool amd) { ... if (!gbpages) gbpages_bit_rsvd = rsvd_bits(7, 7); ... switch (level) { ... case PT64_ROOT_LEVEL: ... rsvd_check-\u003ersvd_bits_mask[1][2] = exb_bit_rsvd | gbpages_bit_rsvd | rsvd_bits(maxphyaddr, 51) | rsvd_bits(13, 29); break; ... } static void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu, struct kvm_mmu *context) { __reset_rsvds_bits_mask(vcpu, \u0026context-\u003eguest_rsvd_check, cpuid_maxphyaddr(vcpu), context-\u003eroot_level, context-\u003enx, guest_cpuid_has_gbpages(vcpu), is_pse(vcpu), guest_cpuid_is_amd(vcpu)); } So, the hint of whether to set this bit as reserved comes from whether the guest cpu has gbpages capability. This comes from CPUID leaf 0x8000_0001.EDX[26].\nRunning cpuid on the host gives,\n... $ cpud -1 ... extended feature flags (0x80000001/edx): SYSCALL and SYSRET instructions = true execution disable = true 1-GB large page support = true ... Root-cause: CPUID The immediate conclusion is: our host support 1GiB pages but our guest CPU does not support it. Digging through the sources shows that only a few server class CPU support this feature in QEMU.\nstatic X86CPUDefinition builtin_x86_defs[] = { ... { .name = \"Skylake-Server\", .level = 0xd, .vendor = CPUID_VENDOR_INTEL, .features[FEAT_8000_0001_EDX] = CPUID_EXT2_LM | CPUID_EXT2_PDPE1GB | CPUID_EXT2_RDTSCP | CPUID_EXT2_NX | CPUID_EXT2_SYSCALL, ... Also, from qemu documentation\npdpe1gb Recommended to allow guest OS to use 1GB size pages. Not included by default in any Intel CPU model. Should be explicitly turned on for all Intel CPU models. Note that not all CPU hardware will support this feature. Solution: passing the CPU model that supports 1GB pages The conclusion is, in QEMU command line, one should specify a CPU that supports this feature (according to QEMU sources) or pass this a flag to the cpus to enable 1GiB large page support.\nqemu-system-x86_64 -cpu Haswell,pdpe1gb ... or\nqemu-system-x86_64 -cpu Skylake-Server ... Having this in our QEMU commandline does not set bit7 as reserved and thus solves the bug we encountered at the beginning of this post.\n",
  "wordCount" : "2320",
  "inLanguage": "en",
  "datePublished": "2020-11-01T00:00:00Z",
  "dateModified": "2020-11-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Vikram Narayanan"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mars-research.github.io/posts/2020/11/qemu-kvm-1gb-pages/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mars Research Group",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mars-research.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mars-research.github.io/" accesskey="h" title="Mars Research Group (Alt + H)">Mars Research Group</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mars-research.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://mars-research.github.io/publications" title="Publications">
                    <span>Publications</span>
                </a>
            </li>
            <li>
                <a href="https://mars-research.github.io/projects" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="https://mars-research.github.io/news" title="News">
                    <span>News</span>
                </a>
            </li>
            <li>
                <a href="https://mars-research.github.io/posts" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://mars-research.github.io/reading-group" title="Reading Group">
                    <span>Reading Group</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://mars-research.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://mars-research.github.io/posts/">Blog</a></div>
    <h1 class="post-title">
      Debugging QEMU/KVM Setup If Something Goes Wrong (e.g., Support for 1GB Pages)
    </h1>
    <div class="post-meta"><span title='2020-11-01 00:00:00 +0000 UTC'>November 1, 2020</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Vikram Narayanan&nbsp;|&nbsp;<a href="https://github.com/mars-research/mars-research.github.io/blob/main/content/posts/2020/11/qemu-kvm-1gb-pages.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> 
  <div class="post-content"><p>In our previous projects, we always did all development on real hardware. For
example, <a href="https://mars-research.github.io/lxds/">LXDs</a> and
<a href="https://mars-research.github.io/lvds/">LVDs</a> required baremetal speed of the
cache-coherence protocol and support for nested virtualization (both systems
use hardware-supported virtualization). So development under QEMU looked
unrealistic. Well, maybe we need to explore more. KVM supports nested
virtualization, but we needed support for features like extended page table
(EPT) switching with VMFUNC. In the end, we were reluctant to take this
approach.</p>
<p>But our most recent project,
<a href="https://mars-research.github.io/redleaf">RedLeaf</a>, is a new operating system
implemented from scratch in Rust. This was the first time we used QEMU/KVM pair
for development and found it extremely effective. Developing OS kernels under
QEMU/KVM has a much quicker development cycle and gives a ton of debugging
opportunities (e.g., attaching GDB, dumping page tables from QEMU,
understanding triple faults, etc.). Plus it removes an extremely annoying long
reboot cycle.</p>
<p>We will describe what we&rsquo;ve learned in a collection of posts and hopefully, our
lessons are useful to others. It took us some time to debug several things that
did not work as expected when run on top of QEMU/KVM. Here, we describe our
experience of debugging 1GB page support with KVM.</p>
<p><strong>Spoiler:</strong> our bug is trivial, we just did not pass the correct CPU model as
an argument. So if you simply want to get it running scroll to the bottom. Our
goal with this post is to share the tricks that allow us to debug similar
issues with the QEMU setup.</p>
<h2 id="the-problem">The problem<a hidden class="anchor" aria-hidden="true" href="#the-problem">#</a></h2>
<p>We started our development with a 3 level pagetable with 2MiB hugepages. Later,
we wanted more memory and decided to support huge pagetables (1GiB pages).</p>
<p>Here is our pagetable setup, trying to direct-map the first 32GiBs of memory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>setup_huge_page_tables:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">; map first P4 entry to P3 table
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rax</span>, <span style="color:#66d9ef">hp3_table</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">or</span> <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">0</span><span style="color:#66d9ef">b11</span> <span style="color:#75715e">; present + writable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> [<span style="color:#66d9ef">hp4_table</span>], <span style="color:#66d9ef">rax</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">;map each P3 entry to a huge 1GiB page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#ae81ff">0</span>         <span style="color:#75715e">; counter variable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>.map_hp3_table:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">; map ecx-th P3 entry to a huge page that starts at address 1GiB*ecx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">1</span> <span style="color:#960050;background-color:#1e0010">&lt;&lt;</span> <span style="color:#ae81ff">30</span>  <span style="color:#75715e">; 1GiB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mul</span> <span style="color:#66d9ef">ecx</span>            <span style="color:#75715e">; start address of ecx-th page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">shl</span> <span style="color:#66d9ef">rdx</span>, <span style="color:#ae81ff">32</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">or</span> <span style="color:#66d9ef">rax</span>, <span style="color:#66d9ef">rdx</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">or</span> <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">0</span><span style="color:#66d9ef">b10000011</span> <span style="color:#75715e">; present + writable + huge
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> [<span style="color:#66d9ef">hp3_table</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">ecx</span> * <span style="color:#ae81ff">8</span>], <span style="color:#66d9ef">rax</span> <span style="color:#75715e">; map ecx-th entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inc</span> <span style="color:#66d9ef">ecx</span>            <span style="color:#75715e">; increase counter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">cmp</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#ae81ff">0x20</span>       <span style="color:#75715e">; if counter == 32, 32 entries in P3 table is mapped
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">jne</span> <span style="color:#66d9ef">.map_hp3_table</span>  <span style="color:#75715e">; else map the next entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">; Apic regions would belong in the first few gigabytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">section</span> <span style="color:#66d9ef">.bss</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>hp4_table:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resb</span> <span style="color:#ae81ff">4096</span>              
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">hp3_table</span>:  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">resb</span> <span style="color:#ae81ff">4096</span>
</span></span></code></pre></div><p>With this boot-time pagetable, everything was good when we run it on bare-metal, but things started to break under QEMU/KVM.
All we had access to was an internal error from KVM and a register dump.</p>
<pre tabindex="0"><code class="language-log" data-lang="log">KVM internal error. Suberror: 1
emulation failure
EAX=80000011 EBX=00000000 ECX=c0000080 EDX=00000000
ESI=00000000 EDI=00000000 EBP=00000000 ESP=01bfa000
EIP=00133025 EFL=00010086 [--S--P-] CPL=0 II=0 A20=1 SMM=0 HLT=0
ES =0018 00000000 ffffffff 00c09300 DPL=0 DS   [-WA]
CS =0010 00000000 ffffffff 00c09b00 DPL=0 CS32 [-RA]
SS =0018 00000000 ffffffff 00c09300 DPL=0 DS   [-WA]
DS =0018 00000000 ffffffff 00c09300 DPL=0 DS   [-WA]
FS =0018 00000000 ffffffff 00c09300 DPL=0 DS   [-WA]
GS =0018 00000000 ffffffff 00c09300 DPL=0 DS   [-WA]
LDT=0000 00000000 0000ffff 00008200 DPL=0 LDT
TR =0000 00000000 0000ffff 00008b00 DPL=0 TSS64-busy
GDT=     0000000000100018 0000000f
IDT=     0000000000000000 00000000
CR0=80000011 CR2=0000000000000000 CR3=0000000000bf8000 CR4=00000020
DR0=0000000000000000 DR1=0000000000000000 DR2=0000000000000000 DR3=0000000000000000
DR6=00000000ffff0ff0 DR7=0000000000000400
EFER=0000000000000500
</code></pre><p>The program counter was pointing to an instruction which accesses the <a href="https://wiki.osdev.org/Printing_To_Screen">VGA
buffer</a></p>
<pre tabindex="0"><code class="language-objdump" data-lang="objdump">  133025:       66 c7 05 00 80 0b 00 48 02                      movw   $0x248,0xb8000(%rip)
</code></pre><p>At this point, what can we do to debug the crash? We were kind of lost, why VGA
buffer, what went wrong?</p>
<h2 id="step-1-enable-kvm-tracing">Step 1: Enable KVM tracing<a hidden class="anchor" aria-hidden="true" href="#step-1-enable-kvm-tracing">#</a></h2>
<p>We start debugging by enabling KVM tracing with Linux tracepoints.  [Linux
tracepoints] (<a href="https://www.kernel.org/doc/html/latest/trace/tracepoints.html">https://www.kernel.org/doc/html/latest/trace/tracepoints.html</a>)
are a lightweight instrumentation facility embedded in the Linux kernel.  One
can dynamically enable these tracepoints by registering a function that would
be called when the tracepoint is executed.</p>
<p>KVM Code has a lot of <a href="https://www.linux-kvm.org/page/Perf_events">tracepoints</a>
for instrumenting various events. The list of tracepoints could be obtained by
running <code>perf list</code> as shown below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ sudo perf list | grep kvm
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  kvm:kvm_emulate_insn                               <span style="color:#f92672">[</span>Tracepoint event<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  kvm:kvm_enter_smm                                  <span style="color:#f92672">[</span>Tracepoint event<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  kvm:kvm_entry                                      <span style="color:#f92672">[</span>Tracepoint event<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  kvm:kvm_eoi                                        <span style="color:#f92672">[</span>Tracepoint event<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  kvm:kvm_exit                                       <span style="color:#f92672">[</span>Tracepoint event<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  kvm:kvm_fast_mmio                                  <span style="color:#f92672">[</span>Tracepoint event<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  kvm:kvm_fpu                                        <span style="color:#f92672">[</span>Tracepoint event<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  kvm:kvm_halt_poll_ns                               <span style="color:#f92672">[</span>Tracepoint event<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  ...
</span></span></code></pre></div><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/rostedt/trace-cmd.git"><code>trace-cmd</code></a>
offers a set of tools to trace and collect these events.</p>
<p>Let&rsquo;s run with all kvm tracepoints <a href="https://www.linux-kvm.org/page/Tracing">enabled</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo trace-cmd record -b <span style="color:#ae81ff">20000</span> -e kvm
</span></span></code></pre></div><p>From the dumped report,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo trace-cmd report &gt; trace-cmd.txt
</span></span></code></pre></div><p>we have some more details</p>
<pre tabindex="0"><code> qemu-system-x86-31218 [000] 159269.806542: kvm_exit:             reason EPT_MISCONFIG rip 0x133025 info 0 0
 qemu-system-x86-31218 [000] 159269.806546: kvm_emulate_insn:     0:133025: ec
 qemu-system-x86-31218 [000] 159269.806547: kvm_emulate_insn:     0:133025: ec FAIL
 qemu-system-x86-31218 [000] 159269.806548: kvm_userspace_exit:   reason KVM_EXIT_INTERNAL_ERROR (17)
 qemu-system-x86-31218 [000] 159269.806548: kvm_fpu:              unload
 qemu-system-x86-31215 [007] 159325.605844: kvm_hv_stimer_cleanup: vcpu_id 0 timer 0
 qemu-system-x86-31215 [007] 159325.605852: kvm_hv_stimer_cleanup: vcpu_id 0 timer 1
 qemu-system-x86-31215 [007] 159325.605852: kvm_hv_stimer_cleanup: vcpu_id 0 timer 2
 qemu-system-x86-31215 [007] 159325.605853: kvm_hv_stimer_cleanup: vcpu_id 0 timer 3
</code></pre><p>Well, grepping <code>KVM_EXIT_INTERNAL_ERROR</code> did not give us much information. But
what caught the eye was that the instruction dump at <code>rip</code> was not what we see in
<code>objdump</code>. So, we tried looking into the previous <code>kvm_emulate_insn</code> logs in
the trace report to see how it is handled.</p>
<p>Below is our previous instance of <code>emulate_insn</code> trace.</p>
<pre tabindex="0"><code> qemu-system-x86-31218 [000] 159269.805554: kvm_exit:             reason IO_INSTRUCTION rip 0xa962 info 1770008 0
 qemu-system-x86-31218 [000] 159269.805555: kvm_emulate_insn:     f0000:a962: ec
 qemu-system-x86-31218 [000] 159269.805555: kvm_userspace_exit:   reason KVM_EXIT_IO (2)
</code></pre><p>From the above, it looks like kvm seem to have failed to fetch the instructions at our
crashed rip (<code>0x131025</code>).</p>
<p>The <code>kvm_emulate_insn</code> trace is located at <a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/x86.c#L5474"><code>arch/x86/kvm/x86.c</code></a>.</p>
<p>The exit reason is an EPT misconfiguration.</p>
<pre tabindex="0"><code> qemu-system-x86-31218 [000] 159269.806542: kvm_exit:             reason EPT_MISCONFIG rip 0x133025 info 0 0
</code></pre><p>and the request for emulation originated from here: <a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/vmx.c#L6166"><code>handle_ept_misconfig</code></a> which matches with our trace log.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">handle_ept_misconfig</span>(<span style="color:#66d9ef">struct</span> kvm_vcpu <span style="color:#f92672">*</span>vcpu)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> handle_mmio_page_fault(vcpu, gpa, true);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (likely(ret <span style="color:#f92672">==</span> RET_MMIO_PF_EMULATE))
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> x86_emulate_instruction(vcpu, gpa, <span style="color:#ae81ff">0</span>, NULL, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">==</span>
</span></span><span style="display:flex;"><span>                                              EMULATE_DONE;
</span></span><span style="display:flex;"><span>	...
</span></span></code></pre></div><p>From <a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/x86.c#L5435"><code>arch/x86/kvm/x86.c</code></a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">x86_emulate_instruction</span>(<span style="color:#66d9ef">struct</span> kvm_vcpu <span style="color:#f92672">*</span>vcpu,
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> cr2,
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">int</span> emulation_type,
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>insn,
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">int</span> insn_len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> x86_emulate_ctxt <span style="color:#f92672">*</span>ctxt <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>vcpu<span style="color:#f92672">-&gt;</span>arch.emulate_ctxt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(emulation_type <span style="color:#f92672">&amp;</span> EMULTYPE_NO_DECODE)) {
</span></span><span style="display:flex;"><span>                init_emulate_ctxt(vcpu);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		... 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                r <span style="color:#f92672">=</span> x86_decode_insn(ctxt, insn, insn_len);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                trace_kvm_emulate_insn_start(vcpu);
</span></span></code></pre></div><h2 id="step-2-taking-a-closer-look-at-function-arguments-with-systemtap">Step 2: Taking a closer look at function arguments with Systemtap<a hidden class="anchor" aria-hidden="true" href="#step-2-taking-a-closer-look-at-function-arguments-with-systemtap">#</a></h2>
<p>We want to understand what goes wrong in decoding the instruction at our
faulting <code>rip</code>. For example, we may want to peek into the arguments to
<code>x86_decode_insn</code> function to observe <code>insn</code> or its return value.</p>
<p>One way is to modify the kernel sources and add more debugging information in
these functions. But that&rsquo;s quite an invasive change. Instead, we use
systemtap, a non-invasive way to attach probes at call and return sites for
various kernel functions without modifying the kernel sources.</p>
<p><a href="https://sourceware.org/systemtap/wiki">Systemtap</a> offers a nice commandline
interface and a scripting language using which one can attach call/return probes
to kernel functions. Additionally, it offers guru mode - where you can place
embedded C blocks that can use kernel datastructures and functions.</p>
<p>The code flow of <code>x86_decode_insn</code> in our scenario is:<br></p>
<p align="center">
  <img src="/images/qemu-kvm-1gb-pages/kvm_callgraph.svg">
</p>
<p>In the above graph, <code>gva_to_gpa</code> and is a function pointer which dynamically changes based
on the context we run the guest on. Instead of trying to dig through the code
to resolve it, we can run systemtap to dynamically figure out which <code>gva_to_gpa</code>
pointer is mapped.</p>
<p>Also, to understand if address translation happens correctly, we monitored both
these calls: <code>kvm_fetch_guest_virt</code> and <code>kvm_vcpu_read_guest_page</code>.</p>
<p>Here is the systemtap script we use to stick a probe at call-site for these
functions.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>global count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>probe module(<span style="color:#e6db74">&#34;kvm&#34;</span>).function(<span style="color:#e6db74">&#34;kvm_fetch_guest_virt&#34;</span>) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;%s eip 0x%08x, addr: 0x%08x, bytes: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ppfunc(), <span style="color:#960050;background-color:#1e0010">$</span>ctxt<span style="color:#f92672">-&gt;</span>eip, <span style="color:#960050;background-color:#1e0010">$</span>addr, <span style="color:#960050;background-color:#1e0010">$</span>bytes);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">&#34;fp_gva_to_gpa: %x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, print_fp(<span style="color:#960050;background-color:#1e0010">$</span>ctxt));
</span></span><span style="display:flex;"><span>                count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// We want to know the gva_to_gpa when our guest is at this rip
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">$</span>addr <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x133025</span>) {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">&#34;fp_gva_to_gpa: %x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, print_fp(<span style="color:#960050;background-color:#1e0010">$</span>ctxt));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>probe module(<span style="color:#e6db74">&#34;kvm&#34;</span>).function(<span style="color:#e6db74">&#34;kvm_vcpu_read_guest_page&#34;</span>) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;  -%s =&gt; gfn 0x%08x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ppfunc(), <span style="color:#960050;background-color:#1e0010">$</span>gfn);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Running this by logging the output to a file,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo stap -v ./kvm.stp -o kvm_stap.log
</span></span></code></pre></div><p>Here is what we have,</p>
<pre tabindex="0"><code>kvm_fetch_guest_virt eip 0x0000cfa6, addr: 0x000fcfa6, bytes: 15
fp_gva_to_gpa: ffffffffa04416e0			// This is what gva_to_gpa points to at the beginning
  -kvm_vcpu_read_guest_page =&gt; gfn 0x000000fc
...
&lt;snip&gt;

kvm_fetch_guest_virt eip 0x00133025, addr: 0x00133025, bytes: 15
fp_gva_to_gpa: ffffffffa0448660			// This is what gva_to_gpa points to when we hit our bug
</code></pre><p>The log shows that for the offending address, we see the record for
<code>kvm_fetch_guest_virt</code>, but we do not see any for <code>kvm_vcpu_read_guest_page</code>,
which means the our <code>gva_to_gpa</code> likely returned an error.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* used for instruction fetching */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kvm_fetch_guest_virt</span>(<span style="color:#66d9ef">struct</span> x86_emulate_ctxt <span style="color:#f92672">*</span>ctxt,
</span></span><span style="display:flex;"><span>				gva_t addr, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>val, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> bytes,
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">struct</span> x86_exception <span style="color:#f92672">*</span>exception)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> kvm_vcpu <span style="color:#f92672">*</span>vcpu <span style="color:#f92672">=</span> emul_to_vcpu(ctxt);
</span></span><span style="display:flex;"><span>	u32 access <span style="color:#f92672">=</span> (kvm_x86_ops<span style="color:#f92672">-&gt;</span>get_cpl(vcpu) <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">?</span> PFERR_USER_MASK : <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> offset;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Inline kvm_read_guest_virt_helper for speed.  */</span>
</span></span><span style="display:flex;"><span>	gpa_t gpa <span style="color:#f92672">=</span> vcpu<span style="color:#f92672">-&gt;</span>arch.walk_mmu<span style="color:#f92672">-&gt;</span>gva_to_gpa(vcpu, addr, access<span style="color:#f92672">|</span>PFERR_FETCH_MASK,
</span></span><span style="display:flex;"><span>						    exception);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (unlikely(gpa <span style="color:#f92672">==</span> UNMAPPED_GVA))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> X86EMUL_PROPAGATE_FAULT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	offset <span style="color:#f92672">=</span> addr <span style="color:#f92672">&amp;</span> (PAGE_SIZE<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (WARN_ON(offset <span style="color:#f92672">+</span> bytes <span style="color:#f92672">&gt;</span> PAGE_SIZE))
</span></span><span style="display:flex;"><span>		bytes <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span>)PAGE_SIZE <span style="color:#f92672">-</span> offset;
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> kvm_vcpu_read_guest_page(vcpu, gpa <span style="color:#f92672">&gt;&gt;</span> PAGE_SHIFT, val,
</span></span><span style="display:flex;"><span>				       offset, bytes);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (unlikely(ret <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> X86EMUL_IO_NEEDED;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> X86EMUL_CONTINUE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>From <code>kallsyms</code>, we can get the actual functions the <code>gva_to_gpa</code> functions pointers point to.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ sudo grep -e ffffffffa04416e0 -e ffffffffa0448660 /proc/kallsyms
</span></span><span style="display:flex;"><span>ffffffffa04416e0 t nonpaging_gva_to_gpa <span style="color:#f92672">[</span>kvm<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>ffffffffa0448660 t paging64_gva_to_gpa  <span style="color:#f92672">[</span>kvm<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>During initialization, paging is turned off, so the function pointer is
pointing to <code>nonpaging_gva_to_gpa</code> and when paging is turned on it points to
<code>paging64_gva_to_gpa</code>. So, at our offending address,
<a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/paging_tmpl.h#L890"><code>paging64_gva_to_gpa</code></a>
likely returns a failure.</p>
<p>All <code>gva_to_gpa</code> helpers are templatized in the file
<a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/paging_tmpl.h"><code>paging_tmpl.h</code></a>.
<code>paging64_gva_to_gpa</code> is nothing but a wrapper around <a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/paging_tmpl.h#L456"><code>paging64_walk_addr</code></a>
which inturn is a wrapper to <a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/paging_tmpl.h#L280"><code>paging64_walk_addr_generic</code></a> which walks the relevant pagetable.</p>
<p>Adding a return probe at this function in the systemtap script would give us the return value.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>global ret_active <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>probe module(<span style="color:#e6db74">&#34;kvm&#34;</span>).function(<span style="color:#e6db74">&#34;paging64_walk_addr_generic&#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">$</span>addr <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x00133025</span>) {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">&#34;Walking: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#960050;background-color:#1e0010">$$</span>parms);
</span></span><span style="display:flex;"><span>                ret_active <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>probe module(<span style="color:#e6db74">&#34;kvm&#34;</span>).function(<span style="color:#e6db74">&#34;paging64_walk_addr_generic&#34;</span>).<span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ret_active <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">&#34;return: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#960050;background-color:#1e0010">$$</span><span style="color:#66d9ef">return</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This gives us:</p>
<pre tabindex="0"><code>Walking: walker=0xffff88140cf07a50 vcpu=0xffff882820b48000 mmu=0xffff882820b48300 addr=0x133025 access=0x10
return: return=0x0
</code></pre><h2 id="step-3-enable-even-more-kvm-tracing">Step 3: Enable even more KVM tracing<a hidden class="anchor" aria-hidden="true" href="#step-3-enable-even-more-kvm-tracing">#</a></h2>
<p>The function (<code>paging64_walk_addr_generic</code>) returns <code>1</code> if it has found a valid
mapping and <code>0</code> otherwise (in case of an error). From systemtap log, we see a
failure in address walk, but we do not know yet what happened.</p>
<p>Fortunately, there are more tracepoints in the page walk <a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/paging_tmpl.h#L280">code</a>.
Also, from <code>perf list</code> we have a bunch of <code>kvm_mmu</code> tracepoints.</p>
<pre tabindex="0"><code>$ sudo perf list | grep kvmmmu
  ...
  kvmmmu:kvm_mmu_set_dirty_bit                       [Tracepoint event]
  kvmmmu:kvm_mmu_set_spte                            [Tracepoint event]
  kvmmmu:kvm_mmu_spte_requested                      [Tracepoint event]
  kvmmmu:kvm_mmu_sync_page                           [Tracepoint event]
  kvmmmu:kvm_mmu_unsync_page                         [Tracepoint event]
  kvmmmu:kvm_mmu_walker_error                        [Tracepoint event]
  ...
</code></pre><p>By enabling the tracepoints in <code>paging64_walk_addr_generic</code>,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo trace-cmd record -b <span style="color:#ae81ff">20000</span> -e kvm -e kvm_mmu_pagetable_walk -e kvm_mmu_paging_element -e kvm_mmu_walker_error
</span></span></code></pre></div><p>we have more information about the error:</p>
<pre tabindex="0"><code> qemu-system-x86-31218 [000] 159269.806542: kvm_exit:             reason EPT_MISCONFIG rip 0x133025 info 0 0
 qemu-system-x86-31218 [000] 159269.806544: kvm_mmu_pagetable_walk: addr 133025 pferr 10 F
 qemu-system-x86-31218 [000] 159269.806545: kvm_mmu_paging_element: pte bf9023 level 4
 qemu-system-x86-31218 [000] 159269.806545: kvm_mmu_paging_element: pte a3 level 3
 qemu-system-x86-31218 [000] 159269.806546: kvm_mmu_walker_error: pferr 9 P|RSVD
 qemu-system-x86-31218 [000] 159269.806546: kvm_emulate_insn:     0:133025: ec
 qemu-system-x86-31218 [000] 159269.806547: kvm_emulate_insn:     0:133025: ec FAIL
 qemu-system-x86-31218 [000] 159269.806548: kvm_userspace_exit:   reason KVM_EXIT_INTERNAL_ERROR (17)
</code></pre><h3 id="pagetable-organization">Pagetable organization<a hidden class="anchor" aria-hidden="true" href="#pagetable-organization">#</a></h3>
<p>Before decoding the error, let&rsquo;s take a quick look at our pagetable organization. We have just two levels (<code>level4</code> and <code>level3</code>) <br></p>
<p align="center">
  <img src="/images/qemu-kvm-1gb-pages/pgtable.svg">
</p>
<p>From the log, the walk was successful for <code>level4</code> table and while walking
<code>level3</code> we get an error which hints that the reserved bit is set on the <code>level3</code>
entry.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">FNAME</span>(walk_addr_generic)(<span style="color:#66d9ef">struct</span> guest_walker <span style="color:#f92672">*</span>walker,
</span></span><span style="display:flex;"><span>                                    <span style="color:#66d9ef">struct</span> kvm_vcpu <span style="color:#f92672">*</span>vcpu, <span style="color:#66d9ef">struct</span> kvm_mmu <span style="color:#f92672">*</span>mmu,
</span></span><span style="display:flex;"><span>                                    gva_t addr, u32 access)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        trace_kvm_mmu_pagetable_walk(addr, access);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (unlikely(is_rsvd_bits_set(mmu, pte, walker<span style="color:#f92672">-&gt;</span>level))) {
</span></span><span style="display:flex;"><span>                        errcode <span style="color:#f92672">=</span> PFERR_RSVD_MASK <span style="color:#f92672">|</span> PFERR_PRESENT_MASK;
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">goto</span> error;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>is_last_gpte(mmu, walker<span style="color:#f92672">-&gt;</span>level, pte));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>error:
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        trace_kvm_mmu_walker_error(walker<span style="color:#f92672">-&gt;</span>fault.error_code);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The check for reserved bit is happening <a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/mmu.c#L3314">here</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">__is_rsvd_bits_set</span>(<span style="color:#66d9ef">struct</span> rsvd_bits_validate <span style="color:#f92672">*</span>rsvd_check, u64 pte, <span style="color:#66d9ef">int</span> level)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> bit7 <span style="color:#f92672">=</span> (pte <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">7</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>, low6 <span style="color:#f92672">=</span> pte <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x3f</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (pte <span style="color:#f92672">&amp;</span> rsvd_check<span style="color:#f92672">-&gt;</span>rsvd_bits_mask[bit7][level<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>		((rsvd_check<span style="color:#f92672">-&gt;</span>bad_mt_xwr <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">1ull</span> <span style="color:#f92672">&lt;&lt;</span> low6)) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In our pagetable entry, we set <code>bit7</code> in the <code>level3</code> entry for enabling 1GiB
pages.  With those inputs, the expression above expands to
<code>rsvd_bits_mask[1][2]</code>. The mask is set in <code>__reset_rsvds_bits_mask</code>.</p>
<p>From <a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/mmu.c#L3679"><code>arch/x86/kvm/mmu.c</code></a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">__reset_rsvds_bits_mask</span>(<span style="color:#66d9ef">struct</span> kvm_vcpu <span style="color:#f92672">*</span>vcpu,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">struct</span> rsvd_bits_validate <span style="color:#f92672">*</span>rsvd_check,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> maxphyaddr, <span style="color:#66d9ef">int</span> level, <span style="color:#66d9ef">bool</span> nx, <span style="color:#66d9ef">bool</span> gbpages,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">bool</span> pse, <span style="color:#66d9ef">bool</span> amd)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>gbpages)
</span></span><span style="display:flex;"><span>		gbpages_bit_rsvd <span style="color:#f92672">=</span> rsvd_bits(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">7</span>);
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (level) {
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> PT64_ROOT_LEVEL:
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>		rsvd_check<span style="color:#f92672">-&gt;</span>rsvd_bits_mask[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> exb_bit_rsvd <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>			gbpages_bit_rsvd <span style="color:#f92672">|</span> rsvd_bits(maxphyaddr, <span style="color:#ae81ff">51</span>) <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>			rsvd_bits(<span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">29</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> reset_rsvds_bits_mask(<span style="color:#66d9ef">struct</span> kvm_vcpu <span style="color:#f92672">*</span>vcpu,
</span></span><span style="display:flex;"><span>				  <span style="color:#66d9ef">struct</span> kvm_mmu <span style="color:#f92672">*</span>context)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	__reset_rsvds_bits_mask(vcpu, <span style="color:#f92672">&amp;</span>context<span style="color:#f92672">-&gt;</span>guest_rsvd_check,
</span></span><span style="display:flex;"><span>				cpuid_maxphyaddr(vcpu), context<span style="color:#f92672">-&gt;</span>root_level,
</span></span><span style="display:flex;"><span>				context<span style="color:#f92672">-&gt;</span>nx, guest_cpuid_has_gbpages(vcpu),
</span></span><span style="display:flex;"><span>				is_pse(vcpu), guest_cpuid_is_amd(vcpu));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So, the hint of whether to set this bit as reserved comes from whether the
guest cpu has gbpages capability. This comes from CPUID leaf
<code>0x8000_0001</code>.EDX[26].</p>
<p>Running cpuid on the host gives,</p>
<pre tabindex="0"><code>...
$ cpud -1
   ...
   extended feature flags (0x80000001/edx):           
      SYSCALL and SYSRET instructions        = true                                                                  
      execution disable                      = true       
      1-GB large page support                = true  
  ...
</code></pre><h2 id="root-cause-cpuid">Root-cause: CPUID<a hidden class="anchor" aria-hidden="true" href="#root-cause-cpuid">#</a></h2>
<p>The immediate conclusion is: our host support 1GiB pages but our guest CPU does
not support it. Digging through the sources shows that only a few server class
CPU support this feature in QEMU.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> X86CPUDefinition builtin_x86_defs[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    {    
</span></span><span style="display:flex;"><span>        .name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Skylake-Server&#34;</span>,
</span></span><span style="display:flex;"><span>        .level <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xd</span>, 
</span></span><span style="display:flex;"><span>        .vendor <span style="color:#f92672">=</span> CPUID_VENDOR_INTEL,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        .features[FEAT_8000_0001_EDX] <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>            CPUID_EXT2_LM <span style="color:#f92672">|</span> CPUID_EXT2_PDPE1GB <span style="color:#f92672">|</span> CPUID_EXT2_RDTSCP <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>            CPUID_EXT2_NX <span style="color:#f92672">|</span> CPUID_EXT2_SYSCALL,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span></code></pre></div><p>Also, from <a href="https://www.qemu.org/docs/master/system/target-i386.html#recommendations-for-kvm-cpu-model-configuration-on-x86-hosts">qemu documentation</a></p>
<pre tabindex="0"><code>pdpe1gb

    Recommended to allow guest OS to use 1GB size pages.

    Not included by default in any Intel CPU model.

    Should be explicitly turned on for all Intel CPU models.

    Note that not all CPU hardware will support this feature.
</code></pre><h2 id="solution-passing-the-cpu-model-that-supports-1gb-pages">Solution: passing the CPU model that supports 1GB pages<a hidden class="anchor" aria-hidden="true" href="#solution-passing-the-cpu-model-that-supports-1gb-pages">#</a></h2>
<p>The conclusion is, in QEMU command line, one should specify a CPU that supports
this feature (according to QEMU sources) or pass this a flag to the cpus to enable 1GiB large page support.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>qemu-system-x86_64 -cpu Haswell,pdpe1gb ...
</span></span></code></pre></div><p>or</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>qemu-system-x86_64 -cpu Skylake-Server ...
</span></span></code></pre></div><p>Having this in our QEMU commandline does not set <code>bit7</code> as reserved and thus
solves the bug we encountered at the beginning of this post.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://mars-research.github.io/">Mars Research Group</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
