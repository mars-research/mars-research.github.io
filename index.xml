<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Mars Research Group</title>
    <link>https://mars-research.github.io/</link>
    <description>Recent content on Mars Research Group</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 30 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://mars-research.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Setting up Alveo FPGAs on Cloudlab - Part 1</title>
      <link>https://mars-research.github.io/posts/2022/01/playing-with-alveo-on-cloudlab-umass-p1/</link>
      <pubDate>Sun, 30 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://mars-research.github.io/posts/2022/01/playing-with-alveo-on-cloudlab-umass-p1/</guid>
      <description>As a systems research team, we build operating systems, low-level software, hack kernels and yet hardware programming always remained on the todo-list of &amp;ldquo;cool, but haven&amp;rsquo;t tried yet&amp;rdquo;. When Cloudlab started introducing FPGA accelerators to their testbed, we got excited and finally decided to give it a try.
Cloudlab is one of the publicly available testbeds for research. In all of our projects, we carry out the whole development process on Cloudlab infrastructure.</description>
      <content:encoded><![CDATA[<p>As a systems research team, we build operating systems, low-level software,
hack kernels and yet hardware programming always remained on the todo-list of &ldquo;cool,
but haven&rsquo;t tried yet&rdquo;. When Cloudlab started introducing FPGA accelerators to
their testbed, we got excited and finally decided to give it a try.</p>
<p>Cloudlab is one of the publicly available testbeds for research. In all of our
projects, we carry out the whole development process on Cloudlab
infrastructure. Recently, UMass Amherst cluster started offering machines with
FPGA accelerator cards.</p>
<p>The official documentation of <a href="https://docs.cloudlab.us/hardware.html">Cloudlab</a>
lists a variety of hardware nodes to choose from based on your needs. As of
this writing, the FPGA machines on UMass cluster is still not listed on this
documentation.</p>
<p>We set up an experiment with <code>fpga-alveo</code> hardware on UMass cluster. This
machine also has a fairly recent CPU <a href="https://ark.intel.com/content/www/us/en/ark/products/199347/intel-xeon-gold-6226r-processor-22m-cache-2-90-ghz.html"><strong>Intel(R) Xeon(R) Gold
6226R</strong></a>.
Our experiment uses stock Ubuntu 18.04 LTS, which is recommended for all Xilinx software versioned <code>v2021.2</code>.</p>
<h3 id="setting-up-xilinx-development-environment">Setting up Xilinx development environment</h3>
<ul>
<li>The first step is to query the PCI bus for the presence of any Xilinx device.
The accelerator cards would show up as two different physical functions (PFs),
one for management (FPGA shell) and one for user programming. More details
<a href="https://xilinx.github.io/XRT/master/html/platforms.html">here</a></li>
</ul>
<pre tabindex="0"><code>sudo lspci -d 10ee:
3b:00.0 Processing accelerators: Xilinx Corporation Device 500c
3b:00.1 Processing accelerators: Xilinx Corporation Device 500d
</code></pre><ul>
<li>
<p>There is a bit of a chicken-and-egg problem in figuring out which hardware is
connected to this machine. There has got to be a better way to figure out the
type of hardware connected to your PCIe bus. But we were lazy and tried to do
a quick search on <em>UMass + cloudlab + fpga</em> to figure out what UMass people
were planning to populate on their cluster and we get a
<a href="https://massopen.cloud/wp-content/uploads/2020/04/Open-Cloud-Workshop-OCT.pptx-2.pdf">hit</a>.
We optimistically assumed they went with the same hardware listed on their
proposal, which was Alveo U280 acceleration card.</p>
</li>
<li>
<p>From here on, things get accelerated a bit. Xilinx has a getting started page
for each hardware that hosts the list of tools you would need to set up the
environment. Here is the page for <a href="https://www.xilinx.com/products/boards-and-kits/alveo/u280.html#gettingStarted">Alveo
U280</a>.</p>
</li>
<li>
<p>We installed the debian packages for the following components that are
available from the <em>Getting Started</em> page. Installing with apt (i.e., <code>apt install xilinx_debian_files.deb</code>)
should automatically install all the needed dependencies.</p>
<ul>
<li>XRT (Xilinux Runtime)</li>
<li>Target Deployment platform</li>
</ul>
</li>
<li>
<p>After installing, the device can be validated using this command. It also
performs a few tests on the hardware.</p>
</li>
</ul>
<pre tabindex="0"><code>$ sudo /opt/xilinx/xrt/bin/xbutil validate -d 0
---------------------------------------------------------------------
INFO: Found 1 cards

INFO: Validating card[0]: xilinx_u280_xdma_201920_3
INFO: == Starting AUX power connector check:
INFO: == AUX power connector check PASSED
INFO: == Starting Power warning check:
INFO: == Power warning check PASSED
INFO: == Starting PCIE link check:
INFO: == PCIE link check PASSED
INFO: == Starting SC firmware version check:
INFO: == SC firmware version check PASSED
INFO: == Starting verify kernel test:
INFO: == verify kernel test PASSED
INFO: == Starting IOPS test:
Maximum IOPS: 84145 (hello)
INFO: == IOPS test PASSED
INFO: == Starting DMA test:
Host -&gt; PCIe -&gt; FPGA write bandwidth = 11262.153007 MB/s
Host &lt;- PCIe &lt;- FPGA read bandwidth = 11899.228409 MB/s
INFO: == DMA test PASSED
INFO: == Starting device memory bandwidth test:
...........
Maximum throughput: 43738 MB/s
INFO: == device memory bandwidth test PASSED
INFO: == Starting PCIE peer-to-peer test:
P2P BAR is not enabled. Skipping validation
INFO: == PCIE peer-to-peer test SKIPPED
INFO: == Starting memory-to-memory DMA test:
M2M is not available. Skipping validation
INFO: == memory-to-memory DMA test SKIPPED
INFO: == Starting host memory bandwidth test:
Host_mem is not available. Skipping validation
INFO: == host memory bandwidth test SKIPPED
INFO: Card[0] validated successfully.

INFO: All cards validated successfully.
</code></pre><ul>
<li>However, to design/program the FPGA, you would need Vitis hardware suite that is
available for download behind a registration wall.</li>
</ul>
<h3 id="installables-behind-a-registration-wall">Installables behind a registration wall</h3>
<p>Below installables are available only after creating a Xilinx account.</p>
<ol>
<li>Development target platform</li>
<li>Vitis Core Development Kit</li>
</ol>
<ul>
<li>Even for a minimal installation, Vitis suite would take around 170 GB of disk
space. As Umass cluster does not support attaching a datastore currently, we
installed all the software in the project specific NFS filesystem that is
available under <code>/proj/&lt;your-project-name/</code>. Please consult with Cloudlab
administrators before installing it in the shared NFS drive.</li>
</ul>
<h3 id="pynq">PYNQ</h3>
<p><a href="https://github.com/Xilinx/PYNQ">PYNQ</a> is an opensource library that provides a
python API for Xilinx platforms. Installing PYNQ is fairly trivial with <code>pip</code>.
However, one can follow advanced setup instructions (such as installing through
<code>Conda</code>) detailed
<a href="https://pynq.readthedocs.io/en/v2.7.0/getting_started/alveo_getting_started.html">here</a></p>
<h3 id="pynq-in-action">PYNQ in action</h3>
<ul>
<li>PYNQ relies on XRT that we installed earlier. So, it&rsquo;s important to source
the XRT environment before using the <code>pynq</code> python module.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>source /opt/xilinx/xrt/setup.sh
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#ae81ff">1</span>]: <span style="color:#f92672">import</span> pynq
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#ae81ff">2</span>]: pynq<span style="color:#f92672">.</span>Device<span style="color:#f92672">.</span>devices
</span></span><span style="display:flex;"><span>Out[<span style="color:#ae81ff">2</span>]: [<span style="color:#f92672">&lt;</span>pynq<span style="color:#f92672">.</span>pl_server<span style="color:#f92672">.</span>xrt_device<span style="color:#f92672">.</span>XrtDevice at <span style="color:#ae81ff">0x7fb8dd4549b0</span><span style="color:#f92672">&gt;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#ae81ff">3</span>]: pynq<span style="color:#f92672">.</span>Device<span style="color:#f92672">.</span>devices[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>name
</span></span><span style="display:flex;"><span>Out[<span style="color:#ae81ff">3</span>]: <span style="color:#e6db74">&#39;xilinx_u280_xdma_201920_3&#39;</span>
</span></span></code></pre></div><h3 id="hello-world---a-vector-addition-on-u280">Hello World - A vector addition on U280</h3>
<ul>
<li>
<p>Vitis_Accel_Examples -
<a href="https://github.com/Xilinx/Vitis_Accel_Examples">https://github.com/Xilinx/Vitis_Accel_Examples</a>
hosts a variety of examples that can be programmed on Vitis supported
platforms. We followed this introductory
<a href="https://www.youtube.com/watch?v=uJ1RPbDkvJI">video</a> to run <code>hello_world</code>
example.</p>
</li>
<li>
<p>To build the examples, you need to source both the XRT and Vitis environment
(Vitis environment brings in their c++ compiler <code>v++</code>).</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>source /opt/xilinx/xrt/setup.sh
</span></span><span style="display:flex;"><span>source /opt/tools/Xilinx/Vitis/2021.2/settings64.sh
</span></span></code></pre></div><ul>
<li>
<p>(Likely) due to the Y2K22 bug, the above examples refuse to compile on version
<code>2021.2</code>. The error would look similar to
<a href="https://support.xilinx.com/s/question/0D52E00006uzPZu/caught-tcl-error-error-2201031626-is-an-invalid-argument-please-specify-an-integer-value?language=en_US">this</a>.</p>
<ul>
<li>
<p>The workaround suggested in the above link is to use <code>faketime</code> package to
force the date before <em>01 January, 2022</em>.</p>
</li>
<li>
<p>One can compile and test for three different <code>TARGETS</code> (<code>sw_emu</code>, <code>hw_emu</code>,
and <code>hw</code>). More description is available on the introductory video linked
above.</p>
</li>
</ul>
</li>
<li>
<p>Invoking <code>make all</code> with <code>TARGET=hw</code> would take a while to finish. It
produces an <code>xclbin</code> file in the end that can be flashed onto the FPGA.</p>
</li>
</ul>
<pre tabindex="0"><code>faketime &#39;2021-12-31 12:00:00&#39; make all TARGET=hw PLATFORM=xilinx_u280_xdma_201920_3  -j 32
...
&lt;snip&gt;
INFO: [v++ 60-2256] Packaging for hardware
INFO: [v++ 60-2460] Successfully copied a temporary xclbin to the output xclbin: /opt/Vitis_Accel_Examples/hello_world/./build_dir.hw.xilinx_u280_xdma_201920_3/vadd.xclbin
INFO: [v++ 60-2343] Use the vitis_analyzer tool to visualize and navigate the relevant reports. Run the following command.
    vitis_analyzer /opt/Vitis_Accel_Examples/hello_world/build_dir.hw.xilinx_u280_xdma_201920_3/vadd.xclbin.package_summary
INFO: [v++ 60-791] Total elapsed time: 0h 0m 20s
INFO: [v++ 60-1653] Closing dispatch client
</code></pre><ul>
<li>Example invocation (running <code>make test</code> with <code>TARGET=hw</code>)</li>
</ul>
<pre tabindex="0"><code>faketime &#39;2021-12-31 12:00:00&#39; make test TARGET=hw PLATFORM=xilinx_u280_xdma_201920_3  -j 32
./hello_world ./build_dir.hw.xilinx_u280_xdma_201920_3/vadd.xclbin
Found Platform
Platform Name: Xilinx
INFO: Reading ./build_dir.hw.xilinx_u280_xdma_201920_3/vadd.xclbin
Loading: &#39;./build_dir.hw.xilinx_u280_xdma_201920_3/vadd.xclbin&#39;
Trying to program device[0]: xilinx_u280_xdma_201920_3
Device[0]: program successful!
TEST PASSED
</code></pre><h3 id="validating-vector-addition-using-pynq">Validating vector addition using PYNQ</h3>
<ul>
<li>Let&rsquo;s validate the hello world vector addition example using PYNQ. We can
use <code>pynq.Overlay</code> class to load the generated <code>xclbin</code> file.</li>
</ul>
<pre tabindex="0"><code>In [4]: ol = pynq.Overlay(&#39;/opt/Vitis_Accel_Examples/hello_world/build_dir.hw.xilinx_u280_xdma_201920_3/vadd.xclbin&#39;)
</code></pre><ul>
<li>It is possible to access the kernel from the <code>xclbin</code> file. Our kernel
(vector addition) is <code>vadd</code>. We can see the signature of the kernel.</li>
</ul>
<pre tabindex="0"><code>In [8]: ol.vadd_1.signature
Out[8]: &lt;Signature (in1:&#39;void*&#39;, in2:&#39;void*&#39;, out_r:&#39;void*&#39;, size:&#39;unsigned int&#39;)&gt;
</code></pre><ul>
<li>Let&rsquo;s create input/output buffers to test the vadd kernel</li>
</ul>
<pre tabindex="0"><code># Allocate buffers
In [9]: in1 = pynq.allocate(32)

In [10]: in2 = pynq.allocate(32)

In [11]: out = pynq.allocate(32)

In [12]: import random

# Populate input data with random numbers
In [13]: for x in range(0, in1.size):
    ...:     in1[x] = random.randint(1, 512)
    ...:     in2[x] = random.randint(1, 512)
    ...:

In [14]: in1
Out[14]:
PynqBuffer([397, 409, 434,  70, 192, 335, 258, 213, 255, 459, 376, 306,
            102, 166, 323,  20, 129, 253, 396, 378, 247, 295, 381,   5,
            446, 217, 481, 140, 115, 285, 477,   5], dtype=uint32)

In [15]: in2
Out[15]:
PynqBuffer([243,  88, 497, 143, 347,  34, 319, 102, 197,  17,  45, 212,
             79, 473, 257, 188, 468, 466, 263, 170,  94, 171, 124,  36,
            454,  73, 172,  27,  50, 279, 381,  27], dtype=uint32)
</code></pre><ul>
<li>The input buffers need to be sync-ed to the device</li>
</ul>
<pre tabindex="0"><code>In [16]: in1.sync_to_device()

In [17]: in2.sync_to_device()
</code></pre><ul>
<li>We can invoke the kernel on the inputs we created (<code>in1</code> and <code>in2</code>) by
invoking the <code>call</code> method on the kernel.</li>
</ul>
<pre tabindex="0"><code>In [18]: ol.vadd_1.call(in1, in2, out, 32)
</code></pre><ul>
<li>Finally, we can validate the output by syncing the <code>out</code> buffer back to the host.</li>
</ul>
<pre tabindex="0"><code>In [19]: out
Out[19]:
PynqBuffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=uint32)

In [20]: out.sync_from_device()

In [21]: out
Out[21]:
PynqBuffer([640, 497, 931, 213, 539, 369, 577, 315, 452, 476, 421, 518,
            181, 639, 580, 208, 597, 719, 659, 548, 341, 466, 505,  41,
            900, 290, 653, 167, 165, 564, 858,  32], dtype=uint32)
</code></pre><h3 id="revisiting-the-node">Revisiting the node</h3>
<p>If you happen to swap out the node, just install the dependencies and also the
kernel modules necessary for accessing the Xilinx devices (<code>xocl.ko</code> and
<code>xclmgmt.ko</code>). The easiest way is to just re-install the XRT component from the
deb package which takes care of installing the kernel modules and other
dependencies.</p>
<p>In Part 2, we will create a Vivado project for Alveo U280 card directly from
Verilog sources.</p>
<h4 id="resources">Resources</h4>
<ul>
<li>
<p>Alveo U280 getting started - <a href="https://www.xilinx.com/products/boards-and-kits/alveo/u280.html#gettingStarted">https://www.xilinx.com/products/boards-and-kits/alveo/u280.html#gettingStarted</a></p>
</li>
<li>
<p>PYNQ docs - <a href="https://pynq.readthedocs.io/en/v2.7.0/index.html">https://pynq.readthedocs.io/en/v2.7.0/index.html</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Debugging QEMU/KVM Setup If Something Goes Wrong (e.g., Support for 1GB Pages)</title>
      <link>https://mars-research.github.io/posts/2020/11/qemu-kvm-1gb-pages/</link>
      <pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mars-research.github.io/posts/2020/11/qemu-kvm-1gb-pages/</guid>
      <description>In our previous projects, we always did all development on real hardware. For example, LXDs and LVDs required baremetal speed of the cache-coherence protocol and support for nested virtualization (both systems use hardware-supported virtualization). So development under QEMU looked unrealistic. Well, maybe we need to explore more. KVM supports nested virtualization, but we needed support for features like extended page table (EPT) switching with VMFUNC. In the end, we were reluctant to take this approach.</description>
      <content:encoded><![CDATA[<p>In our previous projects, we always did all development on real hardware. For
example, <a href="https://mars-research.github.io/lxds/">LXDs</a> and
<a href="https://mars-research.github.io/lvds/">LVDs</a> required baremetal speed of the
cache-coherence protocol and support for nested virtualization (both systems
use hardware-supported virtualization). So development under QEMU looked
unrealistic. Well, maybe we need to explore more. KVM supports nested
virtualization, but we needed support for features like extended page table
(EPT) switching with VMFUNC. In the end, we were reluctant to take this
approach.</p>
<p>But our most recent project,
<a href="https://mars-research.github.io/redleaf">RedLeaf</a>, is a new operating system
implemented from scratch in Rust. This was the first time we used QEMU/KVM pair
for development and found it extremely effective. Developing OS kernels under
QEMU/KVM has a much quicker development cycle and gives a ton of debugging
opportunities (e.g., attaching GDB, dumping page tables from QEMU,
understanding triple faults, etc.). Plus it removes an extremely annoying long
reboot cycle.</p>
<p>We will describe what we&rsquo;ve learned in a collection of posts and hopefully, our
lessons are useful to others. It took us some time to debug several things that
did not work as expected when run on top of QEMU/KVM. Here, we describe our
experience of debugging 1GB page support with KVM.</p>
<p><strong>Spoiler:</strong> our bug is trivial, we just did not pass the correct CPU model as
an argument. So if you simply want to get it running scroll to the bottom. Our
goal with this post is to share the tricks that allow us to debug similar
issues with the QEMU setup.</p>
<h2 id="the-problem">The problem</h2>
<p>We started our development with a 3 level pagetable with 2MiB hugepages. Later,
we wanted more memory and decided to support huge pagetables (1GiB pages).</p>
<p>Here is our pagetable setup, trying to direct-map the first 32GiBs of memory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>setup_huge_page_tables:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">; map first P4 entry to P3 table
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rax</span>, <span style="color:#66d9ef">hp3_table</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">or</span> <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">0</span><span style="color:#66d9ef">b11</span> <span style="color:#75715e">; present + writable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> [<span style="color:#66d9ef">hp4_table</span>], <span style="color:#66d9ef">rax</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">;map each P3 entry to a huge 1GiB page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#ae81ff">0</span>         <span style="color:#75715e">; counter variable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>.map_hp3_table:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">; map ecx-th P3 entry to a huge page that starts at address 1GiB*ecx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">1</span> <span style="color:#960050;background-color:#1e0010">&lt;&lt;</span> <span style="color:#ae81ff">30</span>  <span style="color:#75715e">; 1GiB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mul</span> <span style="color:#66d9ef">ecx</span>            <span style="color:#75715e">; start address of ecx-th page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">shl</span> <span style="color:#66d9ef">rdx</span>, <span style="color:#ae81ff">32</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">or</span> <span style="color:#66d9ef">rax</span>, <span style="color:#66d9ef">rdx</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">or</span> <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">0</span><span style="color:#66d9ef">b10000011</span> <span style="color:#75715e">; present + writable + huge
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> [<span style="color:#66d9ef">hp3_table</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">ecx</span> * <span style="color:#ae81ff">8</span>], <span style="color:#66d9ef">rax</span> <span style="color:#75715e">; map ecx-th entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">inc</span> <span style="color:#66d9ef">ecx</span>            <span style="color:#75715e">; increase counter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">cmp</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#ae81ff">0x20</span>       <span style="color:#75715e">; if counter == 32, 32 entries in P3 table is mapped
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">jne</span> <span style="color:#66d9ef">.map_hp3_table</span>  <span style="color:#75715e">; else map the next entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">; Apic regions would belong in the first few gigabytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">section</span> <span style="color:#66d9ef">.bss</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>hp4_table:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resb</span> <span style="color:#ae81ff">4096</span>              
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">hp3_table</span>:  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">resb</span> <span style="color:#ae81ff">4096</span>
</span></span></code></pre></div><p>With this boot-time pagetable, everything was good when we run it on bare-metal, but things started to break under QEMU/KVM.
All we had access to was an internal error from KVM and a register dump.</p>
<pre tabindex="0"><code class="language-log" data-lang="log">KVM internal error. Suberror: 1
emulation failure
EAX=80000011 EBX=00000000 ECX=c0000080 EDX=00000000
ESI=00000000 EDI=00000000 EBP=00000000 ESP=01bfa000
EIP=00133025 EFL=00010086 [--S--P-] CPL=0 II=0 A20=1 SMM=0 HLT=0
ES =0018 00000000 ffffffff 00c09300 DPL=0 DS   [-WA]
CS =0010 00000000 ffffffff 00c09b00 DPL=0 CS32 [-RA]
SS =0018 00000000 ffffffff 00c09300 DPL=0 DS   [-WA]
DS =0018 00000000 ffffffff 00c09300 DPL=0 DS   [-WA]
FS =0018 00000000 ffffffff 00c09300 DPL=0 DS   [-WA]
GS =0018 00000000 ffffffff 00c09300 DPL=0 DS   [-WA]
LDT=0000 00000000 0000ffff 00008200 DPL=0 LDT
TR =0000 00000000 0000ffff 00008b00 DPL=0 TSS64-busy
GDT=     0000000000100018 0000000f
IDT=     0000000000000000 00000000
CR0=80000011 CR2=0000000000000000 CR3=0000000000bf8000 CR4=00000020
DR0=0000000000000000 DR1=0000000000000000 DR2=0000000000000000 DR3=0000000000000000
DR6=00000000ffff0ff0 DR7=0000000000000400
EFER=0000000000000500
</code></pre><p>The program counter was pointing to an instruction which accesses the <a href="https://wiki.osdev.org/Printing_To_Screen">VGA
buffer</a></p>
<pre tabindex="0"><code class="language-objdump" data-lang="objdump">  133025:       66 c7 05 00 80 0b 00 48 02                      movw   $0x248,0xb8000(%rip)
</code></pre><p>At this point, what can we do to debug the crash? We were kind of lost, why VGA
buffer, what went wrong?</p>
<h2 id="step-1-enable-kvm-tracing">Step 1: Enable KVM tracing</h2>
<p>We start debugging by enabling KVM tracing with Linux tracepoints.  [Linux
tracepoints] (<a href="https://www.kernel.org/doc/html/latest/trace/tracepoints.html">https://www.kernel.org/doc/html/latest/trace/tracepoints.html</a>)
are a lightweight instrumentation facility embedded in the Linux kernel.  One
can dynamically enable these tracepoints by registering a function that would
be called when the tracepoint is executed.</p>
<p>KVM Code has a lot of <a href="https://www.linux-kvm.org/page/Perf_events">tracepoints</a>
for instrumenting various events. The list of tracepoints could be obtained by
running <code>perf list</code> as shown below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ sudo perf list | grep kvm
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  kvm:kvm_emulate_insn                               <span style="color:#f92672">[</span>Tracepoint event<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  kvm:kvm_enter_smm                                  <span style="color:#f92672">[</span>Tracepoint event<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  kvm:kvm_entry                                      <span style="color:#f92672">[</span>Tracepoint event<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  kvm:kvm_eoi                                        <span style="color:#f92672">[</span>Tracepoint event<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  kvm:kvm_exit                                       <span style="color:#f92672">[</span>Tracepoint event<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  kvm:kvm_fast_mmio                                  <span style="color:#f92672">[</span>Tracepoint event<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  kvm:kvm_fpu                                        <span style="color:#f92672">[</span>Tracepoint event<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  kvm:kvm_halt_poll_ns                               <span style="color:#f92672">[</span>Tracepoint event<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  ...
</span></span></code></pre></div><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/rostedt/trace-cmd.git"><code>trace-cmd</code></a>
offers a set of tools to trace and collect these events.</p>
<p>Let&rsquo;s run with all kvm tracepoints <a href="https://www.linux-kvm.org/page/Tracing">enabled</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo trace-cmd record -b <span style="color:#ae81ff">20000</span> -e kvm
</span></span></code></pre></div><p>From the dumped report,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo trace-cmd report &gt; trace-cmd.txt
</span></span></code></pre></div><p>we have some more details</p>
<pre tabindex="0"><code> qemu-system-x86-31218 [000] 159269.806542: kvm_exit:             reason EPT_MISCONFIG rip 0x133025 info 0 0
 qemu-system-x86-31218 [000] 159269.806546: kvm_emulate_insn:     0:133025: ec
 qemu-system-x86-31218 [000] 159269.806547: kvm_emulate_insn:     0:133025: ec FAIL
 qemu-system-x86-31218 [000] 159269.806548: kvm_userspace_exit:   reason KVM_EXIT_INTERNAL_ERROR (17)
 qemu-system-x86-31218 [000] 159269.806548: kvm_fpu:              unload
 qemu-system-x86-31215 [007] 159325.605844: kvm_hv_stimer_cleanup: vcpu_id 0 timer 0
 qemu-system-x86-31215 [007] 159325.605852: kvm_hv_stimer_cleanup: vcpu_id 0 timer 1
 qemu-system-x86-31215 [007] 159325.605852: kvm_hv_stimer_cleanup: vcpu_id 0 timer 2
 qemu-system-x86-31215 [007] 159325.605853: kvm_hv_stimer_cleanup: vcpu_id 0 timer 3
</code></pre><p>Well, grepping <code>KVM_EXIT_INTERNAL_ERROR</code> did not give us much information. But
what caught the eye was that the instruction dump at <code>rip</code> was not what we see in
<code>objdump</code>. So, we tried looking into the previous <code>kvm_emulate_insn</code> logs in
the trace report to see how it is handled.</p>
<p>Below is our previous instance of <code>emulate_insn</code> trace.</p>
<pre tabindex="0"><code> qemu-system-x86-31218 [000] 159269.805554: kvm_exit:             reason IO_INSTRUCTION rip 0xa962 info 1770008 0
 qemu-system-x86-31218 [000] 159269.805555: kvm_emulate_insn:     f0000:a962: ec
 qemu-system-x86-31218 [000] 159269.805555: kvm_userspace_exit:   reason KVM_EXIT_IO (2)
</code></pre><p>From the above, it looks like kvm seem to have failed to fetch the instructions at our
crashed rip (<code>0x131025</code>).</p>
<p>The <code>kvm_emulate_insn</code> trace is located at <a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/x86.c#L5474"><code>arch/x86/kvm/x86.c</code></a>.</p>
<p>The exit reason is an EPT misconfiguration.</p>
<pre tabindex="0"><code> qemu-system-x86-31218 [000] 159269.806542: kvm_exit:             reason EPT_MISCONFIG rip 0x133025 info 0 0
</code></pre><p>and the request for emulation originated from here: <a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/vmx.c#L6166"><code>handle_ept_misconfig</code></a> which matches with our trace log.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">handle_ept_misconfig</span>(<span style="color:#66d9ef">struct</span> kvm_vcpu <span style="color:#f92672">*</span>vcpu)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> handle_mmio_page_fault(vcpu, gpa, true);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (likely(ret <span style="color:#f92672">==</span> RET_MMIO_PF_EMULATE))
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> x86_emulate_instruction(vcpu, gpa, <span style="color:#ae81ff">0</span>, NULL, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">==</span>
</span></span><span style="display:flex;"><span>                                              EMULATE_DONE;
</span></span><span style="display:flex;"><span>	...
</span></span></code></pre></div><p>From <a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/x86.c#L5435"><code>arch/x86/kvm/x86.c</code></a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">x86_emulate_instruction</span>(<span style="color:#66d9ef">struct</span> kvm_vcpu <span style="color:#f92672">*</span>vcpu,
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> cr2,
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">int</span> emulation_type,
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>insn,
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">int</span> insn_len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> x86_emulate_ctxt <span style="color:#f92672">*</span>ctxt <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>vcpu<span style="color:#f92672">-&gt;</span>arch.emulate_ctxt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(emulation_type <span style="color:#f92672">&amp;</span> EMULTYPE_NO_DECODE)) {
</span></span><span style="display:flex;"><span>                init_emulate_ctxt(vcpu);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		... 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                r <span style="color:#f92672">=</span> x86_decode_insn(ctxt, insn, insn_len);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                trace_kvm_emulate_insn_start(vcpu);
</span></span></code></pre></div><h2 id="step-2-taking-a-closer-look-at-function-arguments-with-systemtap">Step 2: Taking a closer look at function arguments with Systemtap</h2>
<p>We want to understand what goes wrong in decoding the instruction at our
faulting <code>rip</code>. For example, we may want to peek into the arguments to
<code>x86_decode_insn</code> function to observe <code>insn</code> or its return value.</p>
<p>One way is to modify the kernel sources and add more debugging information in
these functions. But that&rsquo;s quite an invasive change. Instead, we use
systemtap, a non-invasive way to attach probes at call and return sites for
various kernel functions without modifying the kernel sources.</p>
<p><a href="https://sourceware.org/systemtap/wiki">Systemtap</a> offers a nice commandline
interface and a scripting language using which one can attach call/return probes
to kernel functions. Additionally, it offers guru mode - where you can place
embedded C blocks that can use kernel datastructures and functions.</p>
<p>The code flow of <code>x86_decode_insn</code> in our scenario is:<br></p>
<p align="center">
  <img src="/images/qemu-kvm-1gb-pages/kvm_callgraph.svg">
</p>
<p>In the above graph, <code>gva_to_gpa</code> and is a function pointer which dynamically changes based
on the context we run the guest on. Instead of trying to dig through the code
to resolve it, we can run systemtap to dynamically figure out which <code>gva_to_gpa</code>
pointer is mapped.</p>
<p>Also, to understand if address translation happens correctly, we monitored both
these calls: <code>kvm_fetch_guest_virt</code> and <code>kvm_vcpu_read_guest_page</code>.</p>
<p>Here is the systemtap script we use to stick a probe at call-site for these
functions.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>global count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>probe module(<span style="color:#e6db74">&#34;kvm&#34;</span>).function(<span style="color:#e6db74">&#34;kvm_fetch_guest_virt&#34;</span>) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;%s eip 0x%08x, addr: 0x%08x, bytes: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ppfunc(), <span style="color:#960050;background-color:#1e0010">$</span>ctxt<span style="color:#f92672">-&gt;</span>eip, <span style="color:#960050;background-color:#1e0010">$</span>addr, <span style="color:#960050;background-color:#1e0010">$</span>bytes);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">&#34;fp_gva_to_gpa: %x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, print_fp(<span style="color:#960050;background-color:#1e0010">$</span>ctxt));
</span></span><span style="display:flex;"><span>                count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// We want to know the gva_to_gpa when our guest is at this rip
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">$</span>addr <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x133025</span>) {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">&#34;fp_gva_to_gpa: %x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, print_fp(<span style="color:#960050;background-color:#1e0010">$</span>ctxt));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>probe module(<span style="color:#e6db74">&#34;kvm&#34;</span>).function(<span style="color:#e6db74">&#34;kvm_vcpu_read_guest_page&#34;</span>) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;  -%s =&gt; gfn 0x%08x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ppfunc(), <span style="color:#960050;background-color:#1e0010">$</span>gfn);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Running this by logging the output to a file,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo stap -v ./kvm.stp -o kvm_stap.log
</span></span></code></pre></div><p>Here is what we have,</p>
<pre tabindex="0"><code>kvm_fetch_guest_virt eip 0x0000cfa6, addr: 0x000fcfa6, bytes: 15
fp_gva_to_gpa: ffffffffa04416e0			// This is what gva_to_gpa points to at the beginning
  -kvm_vcpu_read_guest_page =&gt; gfn 0x000000fc
...
&lt;snip&gt;

kvm_fetch_guest_virt eip 0x00133025, addr: 0x00133025, bytes: 15
fp_gva_to_gpa: ffffffffa0448660			// This is what gva_to_gpa points to when we hit our bug
</code></pre><p>The log shows that for the offending address, we see the record for
<code>kvm_fetch_guest_virt</code>, but we do not see any for <code>kvm_vcpu_read_guest_page</code>,
which means the our <code>gva_to_gpa</code> likely returned an error.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* used for instruction fetching */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kvm_fetch_guest_virt</span>(<span style="color:#66d9ef">struct</span> x86_emulate_ctxt <span style="color:#f92672">*</span>ctxt,
</span></span><span style="display:flex;"><span>				gva_t addr, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>val, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> bytes,
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">struct</span> x86_exception <span style="color:#f92672">*</span>exception)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> kvm_vcpu <span style="color:#f92672">*</span>vcpu <span style="color:#f92672">=</span> emul_to_vcpu(ctxt);
</span></span><span style="display:flex;"><span>	u32 access <span style="color:#f92672">=</span> (kvm_x86_ops<span style="color:#f92672">-&gt;</span>get_cpl(vcpu) <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">?</span> PFERR_USER_MASK : <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> offset;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Inline kvm_read_guest_virt_helper for speed.  */</span>
</span></span><span style="display:flex;"><span>	gpa_t gpa <span style="color:#f92672">=</span> vcpu<span style="color:#f92672">-&gt;</span>arch.walk_mmu<span style="color:#f92672">-&gt;</span>gva_to_gpa(vcpu, addr, access<span style="color:#f92672">|</span>PFERR_FETCH_MASK,
</span></span><span style="display:flex;"><span>						    exception);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (unlikely(gpa <span style="color:#f92672">==</span> UNMAPPED_GVA))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> X86EMUL_PROPAGATE_FAULT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	offset <span style="color:#f92672">=</span> addr <span style="color:#f92672">&amp;</span> (PAGE_SIZE<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (WARN_ON(offset <span style="color:#f92672">+</span> bytes <span style="color:#f92672">&gt;</span> PAGE_SIZE))
</span></span><span style="display:flex;"><span>		bytes <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span>)PAGE_SIZE <span style="color:#f92672">-</span> offset;
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> kvm_vcpu_read_guest_page(vcpu, gpa <span style="color:#f92672">&gt;&gt;</span> PAGE_SHIFT, val,
</span></span><span style="display:flex;"><span>				       offset, bytes);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (unlikely(ret <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> X86EMUL_IO_NEEDED;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> X86EMUL_CONTINUE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>From <code>kallsyms</code>, we can get the actual functions the <code>gva_to_gpa</code> functions pointers point to.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ sudo grep -e ffffffffa04416e0 -e ffffffffa0448660 /proc/kallsyms
</span></span><span style="display:flex;"><span>ffffffffa04416e0 t nonpaging_gva_to_gpa <span style="color:#f92672">[</span>kvm<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>ffffffffa0448660 t paging64_gva_to_gpa  <span style="color:#f92672">[</span>kvm<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>During initialization, paging is turned off, so the function pointer is
pointing to <code>nonpaging_gva_to_gpa</code> and when paging is turned on it points to
<code>paging64_gva_to_gpa</code>. So, at our offending address,
<a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/paging_tmpl.h#L890"><code>paging64_gva_to_gpa</code></a>
likely returns a failure.</p>
<p>All <code>gva_to_gpa</code> helpers are templatized in the file
<a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/paging_tmpl.h"><code>paging_tmpl.h</code></a>.
<code>paging64_gva_to_gpa</code> is nothing but a wrapper around <a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/paging_tmpl.h#L456"><code>paging64_walk_addr</code></a>
which inturn is a wrapper to <a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/paging_tmpl.h#L280"><code>paging64_walk_addr_generic</code></a> which walks the relevant pagetable.</p>
<p>Adding a return probe at this function in the systemtap script would give us the return value.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>global ret_active <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>probe module(<span style="color:#e6db74">&#34;kvm&#34;</span>).function(<span style="color:#e6db74">&#34;paging64_walk_addr_generic&#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#960050;background-color:#1e0010">$</span>addr <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x00133025</span>) {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">&#34;Walking: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#960050;background-color:#1e0010">$$</span>parms);
</span></span><span style="display:flex;"><span>                ret_active <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>probe module(<span style="color:#e6db74">&#34;kvm&#34;</span>).function(<span style="color:#e6db74">&#34;paging64_walk_addr_generic&#34;</span>).<span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ret_active <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">&#34;return: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#960050;background-color:#1e0010">$$</span><span style="color:#66d9ef">return</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This gives us:</p>
<pre tabindex="0"><code>Walking: walker=0xffff88140cf07a50 vcpu=0xffff882820b48000 mmu=0xffff882820b48300 addr=0x133025 access=0x10
return: return=0x0
</code></pre><h2 id="step-3-enable-even-more-kvm-tracing">Step 3: Enable even more KVM tracing</h2>
<p>The function (<code>paging64_walk_addr_generic</code>) returns <code>1</code> if it has found a valid
mapping and <code>0</code> otherwise (in case of an error). From systemtap log, we see a
failure in address walk, but we do not know yet what happened.</p>
<p>Fortunately, there are more tracepoints in the page walk <a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/paging_tmpl.h#L280">code</a>.
Also, from <code>perf list</code> we have a bunch of <code>kvm_mmu</code> tracepoints.</p>
<pre tabindex="0"><code>$ sudo perf list | grep kvmmmu
  ...
  kvmmmu:kvm_mmu_set_dirty_bit                       [Tracepoint event]
  kvmmmu:kvm_mmu_set_spte                            [Tracepoint event]
  kvmmmu:kvm_mmu_spte_requested                      [Tracepoint event]
  kvmmmu:kvm_mmu_sync_page                           [Tracepoint event]
  kvmmmu:kvm_mmu_unsync_page                         [Tracepoint event]
  kvmmmu:kvm_mmu_walker_error                        [Tracepoint event]
  ...
</code></pre><p>By enabling the tracepoints in <code>paging64_walk_addr_generic</code>,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo trace-cmd record -b <span style="color:#ae81ff">20000</span> -e kvm -e kvm_mmu_pagetable_walk -e kvm_mmu_paging_element -e kvm_mmu_walker_error
</span></span></code></pre></div><p>we have more information about the error:</p>
<pre tabindex="0"><code> qemu-system-x86-31218 [000] 159269.806542: kvm_exit:             reason EPT_MISCONFIG rip 0x133025 info 0 0
 qemu-system-x86-31218 [000] 159269.806544: kvm_mmu_pagetable_walk: addr 133025 pferr 10 F
 qemu-system-x86-31218 [000] 159269.806545: kvm_mmu_paging_element: pte bf9023 level 4
 qemu-system-x86-31218 [000] 159269.806545: kvm_mmu_paging_element: pte a3 level 3
 qemu-system-x86-31218 [000] 159269.806546: kvm_mmu_walker_error: pferr 9 P|RSVD
 qemu-system-x86-31218 [000] 159269.806546: kvm_emulate_insn:     0:133025: ec
 qemu-system-x86-31218 [000] 159269.806547: kvm_emulate_insn:     0:133025: ec FAIL
 qemu-system-x86-31218 [000] 159269.806548: kvm_userspace_exit:   reason KVM_EXIT_INTERNAL_ERROR (17)
</code></pre><h3 id="pagetable-organization">Pagetable organization</h3>
<p>Before decoding the error, let&rsquo;s take a quick look at our pagetable organization. We have just two levels (<code>level4</code> and <code>level3</code>) <br></p>
<p align="center">
  <img src="/images/qemu-kvm-1gb-pages/pgtable.svg">
</p>
<p>From the log, the walk was successful for <code>level4</code> table and while walking
<code>level3</code> we get an error which hints that the reserved bit is set on the <code>level3</code>
entry.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">FNAME</span>(walk_addr_generic)(<span style="color:#66d9ef">struct</span> guest_walker <span style="color:#f92672">*</span>walker,
</span></span><span style="display:flex;"><span>                                    <span style="color:#66d9ef">struct</span> kvm_vcpu <span style="color:#f92672">*</span>vcpu, <span style="color:#66d9ef">struct</span> kvm_mmu <span style="color:#f92672">*</span>mmu,
</span></span><span style="display:flex;"><span>                                    gva_t addr, u32 access)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        trace_kvm_mmu_pagetable_walk(addr, access);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (unlikely(is_rsvd_bits_set(mmu, pte, walker<span style="color:#f92672">-&gt;</span>level))) {
</span></span><span style="display:flex;"><span>                        errcode <span style="color:#f92672">=</span> PFERR_RSVD_MASK <span style="color:#f92672">|</span> PFERR_PRESENT_MASK;
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">goto</span> error;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>is_last_gpte(mmu, walker<span style="color:#f92672">-&gt;</span>level, pte));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>error:
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        trace_kvm_mmu_walker_error(walker<span style="color:#f92672">-&gt;</span>fault.error_code);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The check for reserved bit is happening <a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/mmu.c#L3314">here</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">__is_rsvd_bits_set</span>(<span style="color:#66d9ef">struct</span> rsvd_bits_validate <span style="color:#f92672">*</span>rsvd_check, u64 pte, <span style="color:#66d9ef">int</span> level)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> bit7 <span style="color:#f92672">=</span> (pte <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">7</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>, low6 <span style="color:#f92672">=</span> pte <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x3f</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (pte <span style="color:#f92672">&amp;</span> rsvd_check<span style="color:#f92672">-&gt;</span>rsvd_bits_mask[bit7][level<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>		((rsvd_check<span style="color:#f92672">-&gt;</span>bad_mt_xwr <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">1ull</span> <span style="color:#f92672">&lt;&lt;</span> low6)) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In our pagetable entry, we set <code>bit7</code> in the <code>level3</code> entry for enabling 1GiB
pages.  With those inputs, the expression above expands to
<code>rsvd_bits_mask[1][2]</code>. The mask is set in <code>__reset_rsvds_bits_mask</code>.</p>
<p>From <a href="https://elixir.bootlin.com/linux/v4.8.4/source/arch/x86/kvm/mmu.c#L3679"><code>arch/x86/kvm/mmu.c</code></a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">__reset_rsvds_bits_mask</span>(<span style="color:#66d9ef">struct</span> kvm_vcpu <span style="color:#f92672">*</span>vcpu,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">struct</span> rsvd_bits_validate <span style="color:#f92672">*</span>rsvd_check,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> maxphyaddr, <span style="color:#66d9ef">int</span> level, <span style="color:#66d9ef">bool</span> nx, <span style="color:#66d9ef">bool</span> gbpages,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">bool</span> pse, <span style="color:#66d9ef">bool</span> amd)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>gbpages)
</span></span><span style="display:flex;"><span>		gbpages_bit_rsvd <span style="color:#f92672">=</span> rsvd_bits(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">7</span>);
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (level) {
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> PT64_ROOT_LEVEL:
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>		rsvd_check<span style="color:#f92672">-&gt;</span>rsvd_bits_mask[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> exb_bit_rsvd <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>			gbpages_bit_rsvd <span style="color:#f92672">|</span> rsvd_bits(maxphyaddr, <span style="color:#ae81ff">51</span>) <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>			rsvd_bits(<span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">29</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> reset_rsvds_bits_mask(<span style="color:#66d9ef">struct</span> kvm_vcpu <span style="color:#f92672">*</span>vcpu,
</span></span><span style="display:flex;"><span>				  <span style="color:#66d9ef">struct</span> kvm_mmu <span style="color:#f92672">*</span>context)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	__reset_rsvds_bits_mask(vcpu, <span style="color:#f92672">&amp;</span>context<span style="color:#f92672">-&gt;</span>guest_rsvd_check,
</span></span><span style="display:flex;"><span>				cpuid_maxphyaddr(vcpu), context<span style="color:#f92672">-&gt;</span>root_level,
</span></span><span style="display:flex;"><span>				context<span style="color:#f92672">-&gt;</span>nx, guest_cpuid_has_gbpages(vcpu),
</span></span><span style="display:flex;"><span>				is_pse(vcpu), guest_cpuid_is_amd(vcpu));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So, the hint of whether to set this bit as reserved comes from whether the
guest cpu has gbpages capability. This comes from CPUID leaf
<code>0x8000_0001</code>.EDX[26].</p>
<p>Running cpuid on the host gives,</p>
<pre tabindex="0"><code>...
$ cpud -1
   ...
   extended feature flags (0x80000001/edx):           
      SYSCALL and SYSRET instructions        = true                                                                  
      execution disable                      = true       
      1-GB large page support                = true  
  ...
</code></pre><h2 id="root-cause-cpuid">Root-cause: CPUID</h2>
<p>The immediate conclusion is: our host support 1GiB pages but our guest CPU does
not support it. Digging through the sources shows that only a few server class
CPU support this feature in QEMU.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> X86CPUDefinition builtin_x86_defs[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    {    
</span></span><span style="display:flex;"><span>        .name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Skylake-Server&#34;</span>,
</span></span><span style="display:flex;"><span>        .level <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xd</span>, 
</span></span><span style="display:flex;"><span>        .vendor <span style="color:#f92672">=</span> CPUID_VENDOR_INTEL,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        .features[FEAT_8000_0001_EDX] <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>            CPUID_EXT2_LM <span style="color:#f92672">|</span> CPUID_EXT2_PDPE1GB <span style="color:#f92672">|</span> CPUID_EXT2_RDTSCP <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>            CPUID_EXT2_NX <span style="color:#f92672">|</span> CPUID_EXT2_SYSCALL,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span></code></pre></div><p>Also, from <a href="https://www.qemu.org/docs/master/system/target-i386.html#recommendations-for-kvm-cpu-model-configuration-on-x86-hosts">qemu documentation</a></p>
<pre tabindex="0"><code>pdpe1gb

    Recommended to allow guest OS to use 1GB size pages.

    Not included by default in any Intel CPU model.

    Should be explicitly turned on for all Intel CPU models.

    Note that not all CPU hardware will support this feature.
</code></pre><h2 id="solution-passing-the-cpu-model-that-supports-1gb-pages">Solution: passing the CPU model that supports 1GB pages</h2>
<p>The conclusion is, in QEMU command line, one should specify a CPU that supports
this feature (according to QEMU sources) or pass this a flag to the cpus to enable 1GiB large page support.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>qemu-system-x86_64 -cpu Haswell,pdpe1gb ...
</span></span></code></pre></div><p>or</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>qemu-system-x86_64 -cpu Skylake-Server ...
</span></span></code></pre></div><p>Having this in our QEMU commandline does not set <code>bit7</code> as reserved and thus
solves the bug we encountered at the beginning of this post.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Kernel Development with Qemu (Printing &#34;Hello World&#34; On Bare Metal)</title>
      <link>https://mars-research.github.io/posts/2020/10/hello-world-on-bare-metal/</link>
      <pubDate>Wed, 28 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mars-research.github.io/posts/2020/10/hello-world-on-bare-metal/</guid>
      <description>How to get started with kernel development on Qemu platform</description>
      <content:encoded><![CDATA[<p>If you plan to start working on a new operating system kernel things get hard
fast&mdash;there is a ton of low-level hardware details you have to understand and
a number of design decisions you have to make (after all, why would you build
yet another kernel&mdash;you have to invent something new, right?).  Complexity is
intimidating. Nevertheless, if you take it step by step, the basics are simple.
And it&rsquo;s worth trying. We&rsquo;re sure you&rsquo;ll venture into your own kernel
story&mdash;multicore-scalability, security, safety, fast device access,</p>
<p>This post provides a minimal set of steps needed to print &ldquo;Hello world!&rdquo; on the
screen.</p>
<h2 id="qemu-the-fastest-way-to-start">Qemu: the Fastest Way to Start</h2>
<p>The fastest way to get started on a new kernel is to use a virtual machine like
Qemu. Note, we like Qemu the most because it is open source (if things go
wrong, you can actually debug what is going on), and good support on Linux
servers (we carry most of our development remotely in a baremetal datacenter,
and Qemu just works out of the box). Compared to running on real hardware
(which has a long reboot cycle, and limited debugging mechanisms), development
under a virtual machine, e.g., Qemu has a much quicker cycle and gives a ton of
debugging opportunities (e.g., attaching GDB, dumping page tables,
understanding triple faults, etc.).  Moreover, for serious kernel development,
the Qemu+KVM bundle provides performance that is nearly identical to bare metal
for most workloads, i.e., a nested page table slows you down by a couple
of percents on workloads that touch a lot of memory, e.g., a hash table, but
overall by running on Qemu+KVM you get a fair estimate of your system&rsquo;s
performance.</p>
<p>Qemu can boot a multiboot-compatible kernel with the (<code>-kernel</code>) option.
Multiboot is a general specification. This is convenient, it can be booted by
any multiboot-compatible boot loader, e.g., GRUB&mdash;this makes it convenient the
moment you are ready to test your kernel on real hardware you can boot it with
GRUB (see below).</p>
<p>The Multiboot specification requires that the kernel binary starts with a
special header. We will make this header in two steps: 1) we will use assembly
to create specific header constants (it&rsquo;s possible to make the header in C, but
what if you program your kernel in Rust?) and 2) we will use a linker script to
make sure that the header is placed exactly at the beginning of the kernel
binary.</p>
<h3 id="multiboot-header">Multiboot Header</h3>
<p>A multiboot header is easy (the code is adapted from <a href="https://www.cs.vu.nl/~herbertb/misc/writingkernels.txt">&ldquo;Writing kernels that boot with Qemu and Grub&rdquo; tutorial by Herbert Boss</a> and it uses
the Intel assembly):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e">; Multiboot v1 - Compliant Header for QEMU 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">; We use multiboot v1 since Qemu &#34;-kernel&#34; doesn&#39;t support 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">; multiboot v2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">; This part MUST be 4-byte aligned, so we solve that issue using &#39;ALIGN 4&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">ALIGN</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">section</span> <span style="color:#66d9ef">.multiboot_header</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">; Multiboot macros to make a few lines later more readable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">MULTIBOOT_PAGE_ALIGN</span>	<span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">&lt;&lt;</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MULTIBOOT_MEMORY_INFO</span>	<span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">&lt;&lt;</span><span style="color:#ae81ff">1</span>                                         
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">MULTIBOOT_HEADER_MAGIC</span>	<span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">0x1BADB002</span>                                   <span style="color:#75715e">; magic number 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">MULTIBOOT_HEADER_FLAGS</span>	<span style="color:#66d9ef">equ</span> <span style="color:#66d9ef">MULTIBOOT_PAGE_ALIGN</span> <span style="color:#960050;background-color:#1e0010">|</span> <span style="color:#66d9ef">MULTIBOOT_MEMORY_INFO</span> <span style="color:#75715e">; flags
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">MULTIBOOT_CHECKSUM</span>	<span style="color:#66d9ef">equ</span> - (<span style="color:#66d9ef">MULTIBOOT_HEADER_MAGIC</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">MULTIBOOT_HEADER_FLAGS</span>)  <span style="color:#75715e">; checksum 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                <span style="color:#75715e">; (magic number + checksum + flags should equal 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">; This is the GRUB Multiboot header. A boot signature
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">dd</span> <span style="color:#66d9ef">MULTIBOOT_HEADER_MAGIC</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dd</span> <span style="color:#66d9ef">MULTIBOOT_HEADER_FLAGS</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dd</span> <span style="color:#66d9ef">MULTIBOOT_CHECKSUM</span>
</span></span></code></pre></div><p>Here we first define several constants, e.g., <code>MULTIBOOT_PAGE_ALIGN</code>, <code>MULTIBOOT_MEMORY_INFO</code>,
<code>MULTIBOOT_HEADER_MAGIC</code>, combine them into <code>MULTIBOOT_HEADER_FLAGS</code> and <code>MULTIBOOT_CHECKSUM</code>, and
then define the header as three 4 byte values in the last three lines.</p>
<p>While this looks criptic in practice it&rsquo;s rather simple.
Go ahead and read the <a href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html">Multiboot Specification, Section 3.1.1</a>
to see which fields are put inside the header.</p>
<p>We can compile this with <code>nasm</code> like</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>nasm -felf32 multiboot_header.asm -o multiboot_header.o
</span></span></code></pre></div><h3 id="linker-script">Linker Script</h3>
<p>Now we need to compile a kernel binary in such a way that the multiboot header appears as the first
section in the ELF file. For this we will use a linker scripts that instructs the linker to copy
sections from multiple files in a specific order:</p>
<pre tabindex="0"><code>ENTRY(start)

SECTIONS {
    . = 0x100000; /* Tells GRUB to load the kernel starting at the 1MB */

    .boot :
    {
        /* Ensure that the multiboot header is at the beginning */
        *(.multiboot_header)
    }

    .text :
    {
        *(.text)
    }

}
</code></pre><p>Here we specify that the kernel entry point will be the <code>start</code> label. The
bootloader that understand ELF format will load the kernel in memory (by the
way, we ask to load the kernel at address <code>0x100000</code>) and will jump to the
entry point specified in the ELF header. The linker will arrange that the ELF
entry point points to the <code>start</code> label in the code. The <code>multiboot_header</code>
will be copied by the linked to be above the rest of the ELF file, e.g., <code>text</code>
section.</p>
<h3 id="building-hello-world">Building Hello world</h3>
<p>Now we&rsquo;re ready to actually implement the code that prints &ldquo;Hello world!&rdquo; on
the screen (this is adapted from <a href="https://intermezzos.github.io/book/first-edition/hello-world.html">intermezzOS</a>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">global</span> <span style="color:#66d9ef">start</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">section</span> <span style="color:#66d9ef">.text</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bits</span> <span style="color:#ae81ff">32</span>    <span style="color:#75715e">; By default, GRUB loads the kernel in 32-bit mode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>start:
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">; Print `Hello world!` on the screen by placing ASCII 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">; characters in the VGA screen buffer that starts at 0xb8000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8000</span>], <span style="color:#ae81ff">0x0248</span> <span style="color:#75715e">; H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8002</span>], <span style="color:#ae81ff">0x0265</span> <span style="color:#75715e">; e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8004</span>], <span style="color:#ae81ff">0x026c</span> <span style="color:#75715e">; l
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8006</span>], <span style="color:#ae81ff">0x026c</span> <span style="color:#75715e">; l
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8008</span>], <span style="color:#ae81ff">0x026f</span> <span style="color:#75715e">; o
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb800a</span>], <span style="color:#ae81ff">0x0220</span> <span style="color:#75715e">;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb800c</span>], <span style="color:#ae81ff">0x0277</span> <span style="color:#75715e">; w
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb800e</span>], <span style="color:#ae81ff">0x026f</span> <span style="color:#75715e">; o
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8010</span>], <span style="color:#ae81ff">0x0272</span> <span style="color:#75715e">; r
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8012</span>], <span style="color:#ae81ff">0x026c</span> <span style="color:#75715e">; l
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8014</span>], <span style="color:#ae81ff">0x0264</span> <span style="color:#75715e">; d
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">word</span> [<span style="color:#ae81ff">0xb8016</span>], <span style="color:#ae81ff">0x0221</span> <span style="color:#75715e">; !
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hlt</span> <span style="color:#75715e">; Halt CPU 
</span></span></span></code></pre></div><p>The code moves ASCII characters <code>H</code>, <code>e</code>, <code>l</code>, etc., into the VGA frame buffer and then halts
the CPU with the <code>hlt</code> instruction.</p>
<p>Now we&rsquo;re ready to build and run this simple kernel. First, we compile the multiboot header:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>nasm -felf32 multiboot_header.asm -o multiboot_header.o
</span></span></code></pre></div><p>Then compile the hello code (let&rsquo;s put it into the <code>boot.asm</code>file):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>nasm -felf32 boot.asm -o boot.o
</span></span></code></pre></div><p>Then invoke a linker to build a final kernel ELF binary:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>ld -m elf_i386 -n -T linker.ld -o kernel.bin boot.o multiboot_header.o
</span></span></code></pre></div><p>And now you&rsquo;re ready to boot with Qemu:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>qemu-system-x86_64 -kernel kernel.bin
</span></span></code></pre></div><h3 id="debugging-with-gdb">Debugging with GDB</h3>
<p>Now lets see how we can debug our kernel with GDB. In the same folder where you work on your
kernel create a simple <code>.gdbinit</code> file</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>target remote localhost:1234
</span></span><span style="display:flex;"><span>symbol-file kernel.bin
</span></span></code></pre></div><p>This file instructs GDB to connect to the <code>localhost:1234</code> and load the symbol file for <code>kernel.bin</code>.
Now we&rsquo;re ready to start our debugging session. In one terminal start Qemu</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>qemu-system-x86_64 -kernel kernel.bin -S -s
</span></span></code></pre></div><p>In another terminal simply start gdb and the <code>.gdbinit</code> will connect it to the Qemu instance
running your OS</p>
<pre tabindex="0"><code>gdb
</code></pre><p>Inside GDB you can set a breakpoint on the <code>start</code> label, e.g.</p>
<pre tabindex="0"><code>(gdb) b start
Breakpoint 1 at 0x100010
</code></pre><p>Now switch layout to <code>regs</code> or <code>asm</code> and hit <code>c</code> for continue. Note, you don&rsquo;t get to immediately
see your &ldquo;Hello world&rdquo; code as Qemu will executes BIOS.</p>
<pre tabindex="0"><code>(gdb) layout regs
(gdb) c
</code></pre><p>You can see your assembly sequence and can single step through it with <code>si</code></p>
<pre tabindex="0"><code>(gdb) si
</code></pre><h3 id="debugging-tips">Debugging tips</h3>
<p>You can always check if your multiboot header is correct by running</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>grub-file --is-x86-multiboot kernel.bin
</span></span></code></pre></div><p>The <code>grub-file</code> is quiet but return 0 if it finds a header, and 1 otherwise.
You can check for the return code with</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>echo $?
</span></span></code></pre></div><p>You can change <code>--is-x86-multiboot</code> to <code>--is-x86-multiboot2</code> for checking the
multiboot2 specification.</p>
<h3 id="automation-with-make">Automation with Make</h3>
<p>It&rsquo;s much more convenient to assemble all build commands in a simple Makefile</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-make" data-lang="make"><span style="display:flex;"><span>kernel <span style="color:#f92672">:=</span> kernel.bin
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>linker_script <span style="color:#f92672">:=</span> linker.ld
</span></span><span style="display:flex;"><span>assembly_source_files <span style="color:#f92672">:=</span> <span style="color:#66d9ef">$(</span>wildcard *.asm<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>assembly_object_files <span style="color:#f92672">:=</span> <span style="color:#66d9ef">$(</span>patsubst %.asm, build/%.o, <span style="color:#66d9ef">$(</span>assembly_source_files<span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.PHONY</span><span style="color:#f92672">:</span> all clean kernel qemu qemu-gdb
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">all</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">$(</span>kernel<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">clean</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	- @rm -fr build *.o <span style="color:#66d9ef">$(</span>kernel<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>	- @rm -f serial.log
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">qemu</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">$(</span>kernel<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>	qemu-system-x86_64 -vga std -s -serial file:serial.log -kernel <span style="color:#66d9ef">$(</span>kernel<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">qemu-gdb</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">$(</span>kernel<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>	qemu-system-x86_64 -vga std -s -serial file:serial.log -S -kernel <span style="color:#66d9ef">$(</span>kernel<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">$(kernel)</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">$(</span>assembly_object_files<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>linker_script<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>	ld -m elf_i386 -n -T <span style="color:#66d9ef">$(</span>linker_script<span style="color:#66d9ef">)</span> -o <span style="color:#66d9ef">$(</span>kernel<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>assembly_object_files<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># compile assembly files
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">build/%.o</span><span style="color:#f92672">:</span> %.asm
</span></span><span style="display:flex;"><span>	@mkdir -p <span style="color:#66d9ef">$(</span>shell dirname $@<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>	nasm -felf32 $&lt; -o $@
</span></span></code></pre></div><h2 id="qemu-booting-a-64bit-kernel">Qemu: Booting a 64bit Kernel</h2>
<p>Remember, Qemu supports only the mutiboot v1 specification, and will only
boot a 32bit ELF binary. Since most likely you will be building a 64bit kernel the <code>-kernel</code>
flag to Qemu is a somewhat limited option. An alternative way to boot is to really go through the full
boot protocol with a real boot loader that can boot our kernel from some kind of a storage device.
The simplest way is to create a CD-ROM image that
contains the GRUB loader and your kernel. Qemu will run the BIOS and the BIOS will follow the
boot protocol loading GRUB the CD-ROM device. Then GRUB that supports both Multiboot v1 and v2
will load our 64bit kernel.</p>
<p>To create a bootable ISO, we&rsquo;re going to use the <code>grub2-mkrescue</code> program that
generates a GRUB rescue image.  We first create a folder layout that will
contain our kernel on disk, and then use  <code>grub2-mkrescue</code> to create a rescue
image.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>mkdir -p build/isofiles/boot/grub
</span></span></code></pre></div><p>The -p flag to mkdir will make the directory we specify, as well as any
directories missing in the path (<code>-p</code> stands for &ldquo;parent&rdquo; as in parent directories).
In other words, this will make the <code>build</code> directory with the <code>isofiles</code> directory inside
that has <code>boot</code> inside, and finally the <code>grub</code> directory inside of that.</p>
<p>In other words we are creating the following layout:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span> build
</span></span><span style="display:flex;"><span>  boot.o
</span></span><span style="display:flex;"><span>  hello.iso
</span></span><span style="display:flex;"><span>  isofiles
</span></span><span style="display:flex;"><span>   boot
</span></span><span style="display:flex;"><span>       grub
</span></span><span style="display:flex;"><span>        grub.cfg
</span></span><span style="display:flex;"><span>       kernel.bin
</span></span></code></pre></div><p>Next, we create <code>grub.cfg</code>, a GRUB configuration file inside of that build/isofiles/boot/grub directory. The GRUB
config file will instruct GRUB how to boot our kernel:</p>
<pre tabindex="0"><code>set timeout=0
set default=0

menuentry &#34;hello&#34; {
    multiboot2 /boot/kernel.bin
    boot
}
</code></pre><p>Note that we set the <code>default</code> GRUB entry to 0 (that&rsquo;s the only entry we have), and configure the <code>timeout</code> to be 0
seconds (after all we just want to boot immediately).</p>
<p>One additional detial here is that we switch from Multiboot v1 to v2, so we use a slightly different <code>multiboot_header.asm</code> file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e">; Multiboot 2 - Compliant Header
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">; https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html (Section 3.1.1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">section</span> <span style="color:#66d9ef">.multiboot_header</span>
</span></span><span style="display:flex;"><span>header_start:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">; Multiboot macros to make a few lines later more readable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">MULTIBOOT_PAGE_ALIGN</span>	<span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">&lt;&lt;</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MULTIBOOT_HEADER_ARCH</span>       <span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">0</span>         <span style="color:#75715e">; 32-bit (protected) mode of i386
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">MULTIBOOT_HEADER_MAGIC</span>	<span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">0xe85250d6</span>          <span style="color:#75715e">; magic number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">MULTIBOOT_CHECKSUM</span>	<span style="color:#66d9ef">equ</span> - (<span style="color:#66d9ef">MULTIBOOT_HEADER_MAGIC</span> <span style="color:#960050;background-color:#1e0010">+</span> (<span style="color:#66d9ef">header_end</span> - <span style="color:#66d9ef">header_start</span>))  <span style="color:#75715e">; checksum
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                                        <span style="color:#75715e">; (magic number + checksum + flags should equal 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MULTIBOOT_TYPE</span>		<span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MULTIBOOT_FLAGS</span>		<span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MULTIBOOT_SIZE</span>		<span style="color:#66d9ef">equ</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">; This is the GRUB Multiboot header. A boot signature
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">dd</span> <span style="color:#66d9ef">MULTIBOOT_HEADER_MAGIC</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dd</span> <span style="color:#66d9ef">MULTIBOOT_HEADER_ARCH</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dd</span> <span style="color:#66d9ef">header_end</span> - <span style="color:#66d9ef">header_start</span> <span style="color:#75715e">; Size of the Header
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">dd</span> <span style="color:#66d9ef">MULTIBOOT_CHECKSUM</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">; Required end tag
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">dw</span> <span style="color:#66d9ef">MULTIBOOT_TYPE</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dw</span> <span style="color:#66d9ef">MULTIBOOT_FLAGS</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dd</span> <span style="color:#66d9ef">MULTIBOOT_SIZE</span>
</span></span><span style="display:flex;"><span>header_end:
</span></span></code></pre></div><p>Again, don&rsquo;t be shy to check the <a href="https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html">Multiboot Specification v2, Section 3.1.1</a>
to see the exact meaning of all fields that we use above.</p>
<p>Now don&rsquo;t have to bother about compiling the 32bit kernel, and instead use normal 64bit ELF file.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>nasm -felf64 boot.asm -o build/boot.o
</span></span><span style="display:flex;"><span>nasm -felf64 multiboot_header.asm -o build/multiboot_header.o
</span></span><span style="display:flex;"><span>ld -n -T linker.ld -o build/kernel.bin  build/boot.o  build/multiboot_header.o
</span></span></code></pre></div><p>Here we ask the linker to put the <code>kernel.bin</code> file inside <code>boot</code>.</p>
<p>We can use <code>grub2-mkrescue</code> to generate a bootable ISO image:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ grub2-mkrescue -o build/hello.iso build/isofiles
</span></span></code></pre></div><p>The -o flag controls the output filename, which we choose to be <code>build/hello.iso</code>. And then we pass it the directory to make the ISO out of, which is the <code>build/isofiles</code> directory we just set up.</p>
<p>This will produce an <code>build/hello.iso</code> file with our kernel inside. Now we can pass this ISO file to QEMU</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ qemu-system-x86_64 -cdrom build/hello.iso
</span></span></code></pre></div><h2 id="booting-off-a-usb-stick">Booting off a USB stick</h2>
<p>Copy the ISO disk image to the USB stick (make sure to use correct device for the
USB drive, otherwise you can overwrite your hard disk). You can use lsblk on Ubuntu
to list block devices</p>
<pre tabindex="0"><code>lsblk
</code></pre><p>For me it&rsquo;s <code>/dev/sda</code> or <code>/dev/sdb</code> but my laptop runs off an NVMe device, so for you
<code>/dev/sda</code> may very well be your root device, not a USB!</p>
<pre tabindex="0"><code>sudo dd if=build/hello.iso of=/dev/&lt;your_usb_drive&gt; bs=1MB
sync
</code></pre><h3 id="boot-on-baremetal-from-a-linux-partition">Boot on baremetal from a Linux partition</h3>
<pre tabindex="0"><code>sudo cp build/kernel.bin /boot/
</code></pre><p>Add the following entry to the grub menu list. On a Linux machine this can
be done by adding this to the /etc/grub.d/40_custom. You might adjust the
root=&lsquo;hd0,2&rsquo; to reflect where your Linux root is on disk, e.g., maybe it&rsquo;s on
root=&lsquo;hd0,1&rsquo;</p>
<pre tabindex="0"><code>set timeout=30
menuentry &#34;Hello World&#34; {
    insmod ext2
    set root=&#39;hd0,1&#39;
    set kernel=&#39;/boot/kernel.bin&#39;
    echo &#34;Loading ${kernel}...&#34;
    multiboot2 ${kernel} ${kernel}
    boot
}
</code></pre><p>Update grub</p>
<pre tabindex="0"><code>  sudo sudo update-grub2
</code></pre><p>Reboot and choose the &ldquo;Hello World&rdquo; entry. Make sure that you can see the grub menu
list by editing /etc/default/grub making sure that GRUB_HIDDEN_TIMEOUT_QUIET is
set to &ldquo;false&rdquo;.</p>
<pre tabindex="0"><code>  GRUB_HIDDEN_TIMEOUT_QUIET=false
</code></pre><h2 id="source-code">Source code</h2>
<p>The source code for this post can be found at  <a href="https://github.com/mars-research/hello-os">hello-os</a> <code>master</code> and
<code>qemu-kernel</code> branches.</p>
<h2 id="resources">Resources</h2>
<ul>
<li>
<p><a href="https://intermezzos.github.io/book/first-edition/booting-up.html">intermezzOS, an operating system for learning</a> provides
an excellent and detailed overview of how to boot into Rust (including printing the &ldquo;Hello World!&rdquo; discussed here.</p>
</li>
<li>
<p><a href="https://os.phil-opp.com/multiboot-kernel/">A minimal Multiboot Kernel</a> is a blog post that describes a minimal multiboot kernel.</p>
</li>
<li>
<p><a href="https://binarydebt.wordpress.com/2018/10/06/how-does-an-x86-processor-boot/">How Does an Intel Processor Boot?</a> is a good
overview of the boot process on Intel CPUs.</p>
</li>
<li>
<p><a href="https://eprint.iacr.org/2016/086.pdf">Intel SGX Explained</a> provides yet another, more in-depth overview of the boot process
on Intel platforms.</p>
</li>
<li>
<p><a href="https://0xax.gitbooks.io/linux-insides/content/Booting/">linux-insides</a> provides an overview of the Linux boot process.</p>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>News</title>
      <link>https://mars-research.github.io/news/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mars-research.github.io/news/</guid>
      <description>2023 Our paper on verifying operating systems using Verus Atmosphere: Towards Practical Verified Kernels in Rust got accepted to KISV&#39;23 (pdf)
Our paper on developing ephemeral virtual TPMs for enabling remote attestation in confidential computing Remote attestation of confidential VMs using ephemeral vTPMs got accepted to ACSAC&#39;23 (pdf)
Our position paper on strengthening the isolation boundary Evolving Operating System Kernels Towards Secure Kernel-Driver Interface got accepted to HotOS&#39;23 (pdf)
Amazon Research Award, Atmosphere: leveraging language safety and operating system design for verification Anton Burtsev (PI).</description>
      <content:encoded><![CDATA[<h3 id="2023">2023</h3>
<ul>
<li>
<p>Our paper on verifying operating systems using Verus <strong>Atmosphere: Towards
Practical Verified Kernels in Rust</strong> got accepted to
<strong><a href="https://kisv-workshop.github.io/program/">KISV'23</a></strong>
(<a href="/doc/2023-kisv-atmo.pdf">pdf</a>)</p>
</li>
<li>
<p>Our paper on developing ephemeral virtual TPMs for enabling remote
attestation in confidential computing <strong>Remote attestation of confidential
VMs using ephemeral vTPMs</strong> got accepted to
<strong><a href="https://www.openconf.org/acsac2023/modules/request.php?module=oc_program&amp;action=program.php&amp;p=program">ACSAC'23</a></strong>
(<a href="/doc/2023-acsac-svsm-vtpm.pdf">pdf</a>)</p>
</li>
<li>
<p>Our position paper on strengthening the isolation boundary <strong>Evolving
Operating System Kernels Towards Secure Kernel-Driver Interface</strong> got
accepted to
<strong><a href="https://www.sigops.org/s/conferences/hotos/2023/#program">HotOS'23</a></strong>
(<a href="/doc/2023-hotos-kernel-interfaces.pdf">pdf</a>)</p>
</li>
<li>
<p>Amazon Research Award, <strong><a href="https://www.cs.utah.edu/amazon-awards-50k-to-prof-anton-burtsev-to-develop-atmosphere-a-secure-and-reliable-operating-system/">Atmosphere: leveraging language safety and
operating system design for
verification</a></strong>
Anton Burtsev (PI). April 2023. $50,000</p>
</li>
<li>
<p>National Science Foundation, <strong>Formal Methods In the Field: Safe, Efficient
Persistent Memory Systems</strong> Anton Burtsev (co-PI). October 2022 - September
2025. My team: $352,700</p>
</li>
<li>
<p>Our high-performance hashtable paper <strong><a href="https://mars-research.github.io/doc/dramhit-esys23.pdf">DRAMHiT: A Hash Table architected for
the Speed of DRAM</a></strong>
got accepted to
<strong><a href="https://2023.eurosys.org/program.html#program">Eurosys'23</a></strong>
(<a href="/doc/2023-eurosys-dramhit.pdf">pdf</a>)</p>
</li>
</ul>
<h3 id="2022">2022</h3>
<ul>
<li>Our paper on kernel isolation <strong>KSplit: Automating Device Driver Isolation</strong>
got accepted to
<strong><a href="https://www.usenix.org/conference/osdi22/technical-sessions">OSDI'22</a></strong>
(<a href="/doc/2022-osdi-ksplit.pdf">pdf</a>, <a href="https://www.youtube.com/watch?v=ZjXXfJ7PbTg">video</a>)</li>
</ul>
<h3 id="2021">2021</h3>
<ul>
<li>
<p>Two papers got accepted to <strong><a href="https://plos-workshop.org/2021/program.php">PLOS'21</a></strong>.</p>
<ul>
<li><strong>Isolation in Rust: What is Missing?</strong>
(<a href="/doc/2021-plos-rust-isolation.pdf">pdf</a>, <a href="https://ess.cs.uni-osnabrueck.de/static/plos21/11_p17_Rust_burtsev.mp4">video</a>)</li>
<li><strong>Understanding the Overheads of Hardware and Language-Based IPC
Mechanisms</strong> (<a href="/doc/2021-plos-ipc-overheads.pdf">pdf</a>, <a href="https://ess.cs.uni-osnabrueck.de/static/plos21/08_p22_IPC_li.mp4">video</a>)</li>
</ul>
</li>
<li>
<p>Tianjiao Huang receives <strong>ICS Outstanding Contribution to Research, 2021</strong>
award for his outstanding <a href="https://www.ics.uci.edu/ugrad/2020-21_ICS_Honors_and_Awards_for_Publication.pdf">contributions to
research</a></p>
</li>
<li>
<p>Anton Burtsev receives <em>University of California, Irvine Chancellor&rsquo;s Award</em>
for <strong>Excellence in Undergraduate Research Mentorship, 2021</strong></p>
</li>
</ul>
<h3 id="2020">2020</h3>
<ul>
<li>
<p>Our paper <strong>RedLeaf: Isolation and Communication in a Safe Operating System</strong>
got accepted to
<strong><a href="https://www.usenix.org/conference/osdi20/technical-sessions">OSDI'20</a></strong> (<a href="/doc/2020-osdi-redleaf.pdf">pdf</a>,
<a href="https://www.youtube.com/watch?v=MKjliJWzs6w">video</a>)</p>
</li>
<li>
<p>Our paper <strong>Lightweight Kernel Isolation with Virtualization and VM Functions</strong> wins the Best Paper Award at <strong>VEE'20</strong>
(<a href="/doc/2020-vee-lvds.pdf">pdf</a>, <a href="https://www.youtube.com/watch?v=vPx5mQS9Mik">video</a>)</p>
<ul>
<li><a href="https://www.cs.uci.edu/cs-researchers-vikram-narayanan-and-anton-burtsev-win-best-paper-award/">UCI News</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Overheads of Hardware and Language-Based IPC Mechanisms</title>
      <link>https://mars-research.github.io/projects/redleaf/lang-ipc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mars-research.github.io/projects/redleaf/lang-ipc/</guid>
      <description>Both lightweight hardware mechanisms and zero-overhead language safety can be leveraged to enforce the isolation of subsystems, e.g., browser plugins, device drivers and kernel extensions, user-defined database and network functions, etc. However, as both technologies are still young, their relative advantages are still unknown.
In this work, we study the overheads of hardware and software isolation mechanisms with the goal to understand their relative advantages and disadvantages for fine-grained isolation of subsystems with tight performance budgets.</description>
      <content:encoded><![CDATA[<p>Both lightweight hardware mechanisms and zero-overhead language safety can be leveraged to enforce the isolation of subsystems, e.g., browser plugins, device drivers and kernel extensions, user-defined database and network functions, etc. However, as both technologies are still young, their relative advantages are still unknown.</p>
<p>In this work, we study the overheads of hardware and software isolation mechanisms with the goal to understand their relative advantages and disadvantages for fine-grained isolation of subsystems with tight performance budgets.</p>
<h2 id="publications">Publications</h2>
<p>Zhaofeng Li, Tianjiao Huang, Vikram Narayanan, Anton Burtsev. <strong>Understanding
the Overheads of Hardware and Language-Based IPC Mechanisms</strong>. In <em>11th
Workshop on Programming Languages and Operating Systems (PLOS)</em>, October 2021.
<a href="https://mars-research.github.io/doc/plos21/plos21-ipc-overheads.pdf">pdf</a></p>
<h2 id="code">Code</h2>
<ul>
<li>Coming soon &hellip;</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Reading Group</title>
      <link>https://mars-research.github.io/reading-group/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mars-research.github.io/reading-group/</guid>
      <description>Details Organizers: Vikram Narayanan, Anton Burtsev Email: narayav1 at uci dot edu, aburtsev at uci dot edu Meeting time/place: Friday, 2:00pm-3:00pm (held remotely) We read and discuss a broad range of papers related to systems research. The topics range from novel system designs (generally results from recent systems conferences) to low-level details of new and existing features of modern CPUs (e.g., SGX, fat pointers (MPX), QPI and cache-coherence, etc.)
Schedule Spring 2022 Date Paper May 9 In-Kernel Control-Flow Integrity on Commodity OSes using ARM Pointer Authentication May 2 Multi-Core, Main-Memory Joins: Sort vs.</description>
      <content:encoded><![CDATA[<h2 id="details">Details</h2>
<ul>
<li><strong>Organizers</strong>: Vikram Narayanan, Anton Burtsev</li>
<li><strong>Email</strong>: narayav1 at uci dot edu, aburtsev at uci dot edu</li>
<li><strong>Meeting time/place</strong>: Friday, 2:00pm-3:00pm (held remotely)</li>
</ul>
<p>We read and discuss a broad range of papers related to systems research. The
topics range from novel system designs (generally results from recent systems
conferences) to low-level details of new and existing features of modern CPUs
(e.g., SGX, fat pointers (MPX), QPI and cache-coherence, etc.)</p>
<h2 id="schedule">Schedule</h2>
<style>
table th:first-of-type {
    width: 10%;
}
</style>
<h3 id="spring-2022">Spring 2022</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Date</th>
<th style="text-align:left">Paper</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">May 9</td>
<td style="text-align:left"><a href="https://www.usenix.org/conference/usenixsecurity22/presentation/yoo">In-Kernel Control-Flow Integrity on Commodity OSes using ARM Pointer Authentication</a></td>
</tr>
<tr>
<td style="text-align:left">May 2</td>
<td style="text-align:left"><a href="https://dl.acm.org/doi/10.14778/2732219.2732227">Multi-Core, Main-Memory Joins: Sort vs. Hash Revisited</a></td>
</tr>
</tbody>
</table>
<h3 id="winter-2022">Winter 2022</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Date</th>
<th style="text-align:left">Paper</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">March 18</td>
<td style="text-align:left"><a href="https://dl.acm.org/doi/10.1145/3503222.3507762">Clio: A Hardware-Software Co-Designed Disaggregated Memory System</a></td>
</tr>
<tr>
<td style="text-align:left">March 11</td>
<td style="text-align:left"><a href="https://dl.acm.org/doi/abs/10.1145/3492321.3519560">You Shall Not (by)Pass! Practical, Secure, and Fast PKU-based Sandboxing</a> (<a href="https://arxiv.org/pdf/2110.04788.pdf">preprint</a>)</td>
</tr>
<tr>
<td style="text-align:left">Mar 4</td>
<td style="text-align:left"><a href="https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/2020oakland-cornucopia.pdf">Cornucopia: Temporal Safety for CHERI Heaps</a></td>
</tr>
<tr>
<td style="text-align:left">Feb 18</td>
<td style="text-align:left"><a href="https://www.usenix.org/system/files/sec21-farkhani.pdf">PTAuth: Temporal Memory Safety via Robust Points-to Authentication</a></td>
</tr>
<tr>
<td style="text-align:left">Feb 11</td>
<td style="text-align:left"><a href="https://www.usenix.org/system/files/sec19fall_liljestrand_prepub.pdf">PAC it up: Towards Pointer Integrity using ARM Pointer Authentication</a></td>
</tr>
<tr>
<td style="text-align:left">Feb 4</td>
<td style="text-align:left"><a href="http://nebelwelt.net/files/22NDSS2.pdf">Preventing Kernel Hacks with HAKC</a></td>
</tr>
<tr>
<td style="text-align:left">Jan 28</td>
<td style="text-align:left"><a href="https://www.usenix.org/system/files/sec20-connor.pdf">PKU Pitfalls: Attacks on PKU-based Memory Isolation Systems</a></td>
</tr>
<tr>
<td style="text-align:left">Jan 21</td>
<td style="text-align:left"><a href="https://www.usenix.org/system/files/sec19-vahldiek-oberwagner_0.pdf">ERIM: Secure, Efficient In-process Isolation with Protection Keys (MPK)</a></td>
</tr>
</tbody>
</table>
<h3 id="fall-2021">Fall 2021</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Date</th>
<th style="text-align:left">Paper</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Dec 28</td>
<td style="text-align:left"><a href="https://www.usenix.org/system/files/sec20-narayan.pdf">Retrofitting Fine Grain Isolation in the Firefox Renderer</a></td>
</tr>
<tr>
<td style="text-align:left">Dec 21</td>
<td style="text-align:left"><a href="https://people.eecs.berkeley.edu/~necula/Papers/xfi-osdi06.pdf">XFI: Software Guards for System Address Spaces</a></td>
</tr>
<tr>
<td style="text-align:left">Nov 12</td>
<td style="text-align:left"><a href="https://www.usenix.org/legacy/events/fast10/tech/full_papers/sundararaman.pdf">Membrane: Operating System Support for Restartable File Systems</a></td>
</tr>
<tr>
<td style="text-align:left">Nov 5</td>
<td style="text-align:left"><a href="https://ieeexplore.ieee.org/document/9546453/">Efficiently Recovering Stateful System Components of Multi-server Microkernels</a></td>
</tr>
<tr>
<td style="text-align:left">Oct 29</td>
<td style="text-align:left"><a href="https://rcs.uwaterloo.ca/~ali/papers/sosp21-aurora.pdf">The Aurora Single Level Store Operating System</a></td>
</tr>
</tbody>
</table>
<h3 id="spring-2021">Spring 2021</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Date</th>
<th style="text-align:left">Paper</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Jun 11</td>
<td style="text-align:left"><a href="https://www.usenix.org/system/files/fast21-miller.pdf">High Velocity Kernel File Systems with Bento</a></td>
</tr>
<tr>
<td style="text-align:left">Jun 4</td>
<td style="text-align:left"><a href="http://cseweb.ucsd.edu/~mhoseinzadeh/hoseinzadeh-corundum-asplos21.pdf">Corundum: Statically-Enforced Persistent Memory Safety</a></td>
</tr>
<tr>
<td style="text-align:left">May 28</td>
<td style="text-align:left"><a href="https://dl.acm.org/doi/10.1145/3133956.3134069">DIFUZE: Interface Aware Fuzzing for Kernel Drivers</a></td>
</tr>
<tr>
<td style="text-align:left">May 21</td>
<td style="text-align:left"><a href="https://mars-research.github.io/doc/lvds-vee20.pdf">Lightweight Kernel Isolation with Virtualization and VM Functions</a></td>
</tr>
<tr>
<td style="text-align:left">May 14</td>
<td style="text-align:left"><a href="https://unsworks.unsw.edu.au/fapi/datastream/unsworks:8363/SOURCE02?view=true">A Principled Approach To KernelMemory Management - Chapter 4</a></td>
</tr>
<tr>
<td style="text-align:left">Apr 16</td>
<td style="text-align:left"><a href="https://pages.cs.wisc.edu/~swift/papers/asplos13_fgft.pdf">Fine-Grained Fault Tolerance using Device Checkpoints</a></td>
</tr>
<tr>
<td style="text-align:left">Apr 2</td>
<td style="text-align:left"><a href="https://cseweb.ucsd.edu/~yiying/LegoOS-OSDI18.pdf">LegoOS: A Disseminated, Distributed OS for Hardware Resource Disaggregation</a></td>
</tr>
</tbody>
</table>
<h3 id="winter-2021">Winter 2021</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Date</th>
<th style="text-align:left">Paper</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Mar 22</td>
<td style="text-align:left"><a href="https://www.usenix.org/system/files/sec21summer_liljestrand.pdf">PACStack: an Authenticated Call Stack</a></td>
</tr>
<tr>
<td style="text-align:left">Mar 15</td>
<td style="text-align:left"><a href="https://arxiv.org/pdf/2103.03443.pdf">Lord of the Ring(s): Side Channel Attacks on the CPU On-Chip Ring Interconnect Are Practical</a></td>
</tr>
<tr>
<td style="text-align:left">Mar 9</td>
<td style="text-align:left"><a href="https://unsat.cs.washington.edu/papers/nelson-hyperkernel.pdf">Hyperkernel: Push-Button Verification of an OS Kernel</a></td>
</tr>
<tr>
<td style="text-align:left">Feb 26</td>
<td style="text-align:left"><a href="https://unsat.cs.washington.edu/papers/nelson-serval.pdf">Scaling symbolic evaluation for automatedverification of systems code with Serval</a></td>
</tr>
<tr>
<td style="text-align:left">Feb 12, 19</td>
<td style="text-align:left"><a href="https://cseweb.ucsd.edu/~yiying/RustStudy-PLDI20.pdf">Understanding Memory and Thread Safety Practicesand Issues in Real-World Rust Programs</a></td>
</tr>
<tr>
<td style="text-align:left">Feb 5</td>
<td style="text-align:left"><a href="https://people.mpi-sws.org/~dreyer/papers/safe-sysprog-rust/paper.pdf">Safe Systems Programming in Rust : The Promise and the Challenge</a></td>
</tr>
<tr>
<td style="text-align:left">Jan 22</td>
<td style="text-align:left"><a href="https://people.eecs.berkeley.edu/~necula/Papers/pcc_osdi96.ps">Safe Kernel Extensions Without Run-Time Checking</a></td>
</tr>
<tr>
<td style="text-align:left">Jan 15</td>
<td style="text-align:left"><a href="https://edolstra.github.io/pubs/nixos-icfp2008-final.pdf">NixOS: A Purely Functional Linux Distribution</a></td>
</tr>
</tbody>
</table>
<h3 id="fall-2020">Fall 2020</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Date</th>
<th style="text-align:left">Paper</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Dec 18</td>
<td style="text-align:left"><a href="https://www.usenix.org/conference/atc20/presentation/farshin">Reexamining Direct Cache Access to Optimize I/O Intensive Applications for Multi-hundred-gigabit Networks</a></td>
</tr>
<tr>
<td style="text-align:left">Nov 27</td>
<td style="text-align:left"><a href="https://www.usenix.org/conference/osdi14/technical-sessions/presentation/kuznetsov">Code-Pointer Integrity</a></td>
</tr>
<tr>
<td style="text-align:left">Nov 20</td>
<td style="text-align:left"><a href="https://www.usenix.org/conference/nsdi19/presentation/didona">Size-aware Sharding For Improving Tail Latencies in In-memory Key-value Stores</a></td>
</tr>
<tr>
<td style="text-align:left">Nov 16</td>
<td style="text-align:left"><a href="https://www.usenix.org/conference/nsdi14/technical-sessions/presentation/lim">MICA: A Holistic Approach to Fast In-Memory Key-Value Storage</a></td>
</tr>
<tr>
<td style="text-align:left">Nov 6</td>
<td style="text-align:left"><a href="https://www.usenix.org/conference/osdi20/presentation/brunella">hXDP: Efficient Software Packet Processing on FPGA NICs</a></td>
</tr>
<tr>
<td style="text-align:left">Nov 3</td>
<td style="text-align:left"><a href="https://www.usenix.org/conference/osdi20/presentation/boos">Theseus: an Experiment in Operating System Structure and State Management</a></td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    
    <item>
      <title>Recent Publications</title>
      <link>https://mars-research.github.io/publications/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mars-research.github.io/publications/</guid>
      <description>2023 Vikram Narayanan, Claudio Carvalho*, Angelo Ruocco*, Gheorghe Almsi*, James Bottomley*, Mengmei Ye*, Tobin Feldman-Fitzthum*, Daniele Buono*, Hubertus Franke*, and Anton Burtsev. (*IBM Research) Remote attestation of confidential VMs using ephemeral vTPMs. In Proceedings of the 39th Annual Computer Security Applications Conference (ACSAC 2023), December 2023.
Xiangdong Chen, Zhaofeng Li, Vikram Narayanan and Anton Burtsev. Atmosphere: Towards Practical Verified Kernels in Rust. In Proceedings of the 1st Workshop on Kernel Isolation, Safety and Verification (KISV 2023), October 2023.</description>
      <content:encoded><![CDATA[<h3 id="2023">2023</h3>
<p>Vikram Narayanan, Claudio Carvalho<sup>*</sup>, Angelo Ruocco<sup>*</sup>,
Gheorghe Almsi<sup>*</sup>, James Bottomley<sup>*</sup>, Mengmei
Ye<sup>*</sup>, Tobin Feldman-Fitzthum<sup>*</sup>, Daniele Buono<sup>*</sup>,
Hubertus Franke<sup>*</sup>, and Anton Burtsev. (<sup>*</sup>IBM Research)
<a href="/doc/2023-acsac-svsm-vtpm.pdf">Remote attestation of confidential VMs using ephemeral
vTPMs</a>. In <em>Proceedings of the 39th Annual
Computer Security Applications Conference (ACSAC 2023)</em>, December 2023.</p>
<p>Xiangdong Chen, Zhaofeng Li, Vikram Narayanan and Anton Burtsev. <a href="/doc/2023-kisv-atmo.pdf">Atmosphere:
Towards Practical Verified Kernels in Rust</a>. In
<em>Proceedings of the 1st Workshop on Kernel Isolation, Safety and Verification
(KISV 2023)</em>, October 2023.</p>
<p>Arthur Lafrance (University of California, Irvine), David Detweiler (University
of California, Irvine), Zhaofeng Li, Xiangdong Chen, Vikram Narayanan and Anton
Burtsev. <a href="/doc/2023-plos-rust-zerocopy.pdf">Extending Rust with Support for Zero Copy
Communication</a>. In <em>Proceedings of the
12th Workshop on Programming Languages and Operating Systems (PLOS 2023)</em>,
October 2023.</p>
<p>Anton Burtsev, Vikram Narayanan, Yongzhe Huang, Kaiming Huang, Gang Tan, and
Trent Jaeger. <a href="/doc/2023-hotos-kernel-interfaces.pdf">Evolving Operating System Kernels Towards Secure Kernel-Driver
Interfaces</a>. In <em>Proceedings of the 19th
Workshop on Hot Topics in Operating Systems (HOTOS &lsquo;23)</em>. June 2023.</p>
<p>Vikram Narayanan and Anton Burtsev. <a href="/doc/2023-ieee-sp-mag.pdf">The Opportunities and Limitations of
Extended Page Table Switching for Fine-Grained
Isolation</a>. In <em>IEEE
Security &amp; Privacy Magazine vol. 21, no. 3, pp. 16-26</em>, May-June 2023.</p>
<p>Vikram Narayanan, David Detweiler, Tianjiao Huang, and Anton Burtsev. <a href="/doc/2023-eurosys-dramhit.pdf">DRAMHiT:
A Hash Table architected for the Speed of
DRAM</a>.  In <em>Proceedings
of the 18th European Conference on Computer Systems (EuroSys &lsquo;23)</em>, May 2023.</p>
<h3 id="2022">2022</h3>
<p>Yongzhe Huang, Vikram Narayanan, David Detweiler, Kaiming Huang, Gang Tan,
Trent Jaeger, and Anton Burtsev.  <a href="/doc/2022-osdi-ksplit.pdf">KSplit: Automating Device Driver
Isolation</a>.  In <em>16th
USENIX Symposium on Operating Systems Design and Implementation (OSDI &lsquo;22)</em>,
July 2022.</p>
<h3 id="2021">2021</h3>
<p>Zhaofeng Li, Tianjiao Huang, Vikram Narayanan and Anton Burtsev (University of
California, Irvine). <a href="/doc/2021-plos-ipc-overheads.pdf">Understanding the Overheads of Hardware and
Language-Based IPC Mechanisms</a>. In
<em>Proceedings of the 11th Workshop on Programming Languages and Operating
Systems (PLOS 2021)</em>, October 2021.</p>
<p>Anton Burtsev, Dan Appel, David Detweiler, Tianjiao Huang, Zhaofeng Li, Vikram
Narayanan (University of California, Irvine) and Gerd Zellweger (VMware
Research). <a href="/doc/2021-plos-rust-isolation.pdf">Isolation in Rust: What is Missing?</a>.
In <em>Proceedings of the 11th Workshop on Programming Languages and Operating
Systems (PLOS 2021)</em>, October 2021.</p>
<h3 id="2020">2020</h3>
<p>Vikram Narayanan, Tianjiao Huang, David Detweiler, Dan Appel, Zhaofeng
Li, Gerd Zellweger, Anton Burtsev. <a href="/doc/2020-osdi-redleaf.pdf">RedLeaf: Isolation and Communication in a
Safe Operating
System</a>. In
<em>14th USENIX Symposium on Operating Systems Design and Implementation (OSDI)</em>,
November 2020.</p>
<p>Vikram Narayanan, Yongzhe Huang, Gang Tan, Trent Jaeger, and Anton
Burtsev. <a href="/doc/2020-vee-lvds.pdf">Lightweight Kernel Isolation with Virtualization and VM
Functions</a>. In <em>Proceedings of the 16th ACM SIGPLAN/SIGOPS
International Conference on Virtual Execution Environments (VEE 20)</em>, March
2020. [Best Paper Award]</p>
<h3 id="2019">2019</h3>
<p>Vikram Narayanan, Abhiram Balasubramanian, Charlie Jacobsen, Sarah Spall,
Scott Bauer, Michael Quigley, Aftab Hussain, Abdullah Younis, Junjie Shen,
Moinak Bhattacharyya, and Anton Burtsev. <a href="/doc/2019-atc-lxds.pdf">LXDs: Towards Isolation of Kernel
Subsystems</a>. In <em>2019
USENIX Annual Technical Conference (USENIX ATC 19)</em>, July 2019.</p>
<p>Vikram Narayanan (University of California, Irvine), Marek S. Baranowski
(University of Utah), Leonid Ryzhyk (VMware Research), Zvonimir Rakamari
(University of Utah), Anton Burtsev (University of California, Irvine).
<a href="/doc/2019-hotos-redleaf.pdf">RedLeaf: Towards An Operating System for Safe and Verified
Firmware</a>. In <em>Proceedings of the 17th Workshop on Hot Topics
in Operating Systems (HotOS)</em>, May 2019.</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
